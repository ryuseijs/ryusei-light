{"version":3,"file":"ryuseilight-complete.min.js","sources":["../../src/js/constants/characters.ts","../../src/js/constants/categories.ts","../../src/js/utils/type/type.ts","../../src/js/utils/array/toArray/toArray.ts","../../src/js/utils/dom/addClass/addClass.ts","../../src/js/utils/dom/append/append.ts","../../src/js/utils/object/forOwn/forOwn.ts","../../src/js/utils/object/assign/assign.ts","../../src/js/utils/dom/attr/attr.ts","../../src/js/utils/dom/query/query.ts","../../src/js/utils/dom/styles/styles.ts","../../src/js/utils/dom/tag/tag.ts","../../src/js/utils/dom/text/text.ts","../../src/js/utils/error/assert/assert.ts","../../src/js/constants/project.ts","../../src/js/utils/map/before/before.ts","../../src/js/utils/map/find/find.ts","../../src/js/utils/string/startsWith/startsWith.ts","../../src/js/core/Lexer/Lexer.ts","../../src/js/constants/classes.ts","../../src/js/event/EventBus.ts","../../src/js/core/Renderer/Renderer.ts","../../src/js/utils/string/escapeHtml/escapeHtml.ts","../../src/js/constants/regexp.ts","../../src/js/languages/css/css.ts","../../src/js/languages/javascript/javascript.ts","../../src/js/languages/html/html.ts","../../src/js/languages/jsx/jsx.ts","../../src/js/languages/none/none.ts","../../src/js/languages/xml/xml.ts","../../src/js/languages/typescript/typescript.ts","../../src/js/languages/json/json.ts","../../src/js/languages/scss/scss.ts","../../src/js/languages/svg/svg.ts","../../src/js/languages/tsx/tsx.ts","../../src/js/languages/vue/vue.ts","../../src/js/core/RyuseiLight/RyuseiLight.ts","../../src/js/components/ActiveLines/ActiveLines.ts","../../src/js/components/Caption/Caption.ts","../../src/js/components/Copy/Copy.ts","../../src/js/utils/dom/create/create.ts","../../src/js/components/Diff/Diff.ts","../../src/js/components/Gutter/Gutter.ts","../../src/js/utils/error/error/error.ts","../../src/js/utils/function/throttle/throttle.ts","../../src/js/components/LanguageName/LanguageName.ts","../../src/js/components/LineNumbers/LineNumbers.ts","../../src/js/components/Overlay/Overlay.ts","../../src/js/build/complete.ts"],"sourcesContent":["/**\n * The line break character.\n *\n * @private\n * @since 0.0.1\n */\nexport const LINE_BREAK = '\\n';\n","export const CATEGORY_KEYWORD    = 'keyword';\nexport const CATEGORY_CONSTANT   = 'constant';\nexport const CATEGORY_COMMENT    = 'comment';\nexport const CATEGORY_TAG        = 'tag';\nexport const CATEGORY_TAG_CLOSE  = 'tag.close';\nexport const CATEGORY_SELECTOR   = 'selector';\nexport const CATEGORY_ATRULE     = 'atrule';\nexport const CATEGORY_ATTRIBUTE  = 'attr';\nexport const CATEGORY_PROPERTY   = 'prop';\nexport const CATEGORY_VALUE      = 'value';\nexport const CATEGORY_VARIABLE   = 'variable';\nexport const CATEGORY_ENTITY     = 'entity';\nexport const CATEGORY_CDATA      = 'cdata';\nexport const CATEGORY_PROLOG     = 'prolog';\nexport const CATEGORY_IDENTIFIER = 'identifier';\nexport const CATEGORY_STRING     = 'string';\nexport const CATEGORY_NUMBER     = 'number';\nexport const CATEGORY_BOOLEAN    = 'boolean';\nexport const CATEGORY_FUNCTION   = 'function';\nexport const CATEGORY_CLASS      = 'class';\nexport const CATEGORY_DECORATOR  = 'decorator';\nexport const CATEGORY_REGEXP     = 'regexp';\nexport const CATEGORY_OPERATOR   = 'operator';\nexport const CATEGORY_BRACKET    = 'bracket';\nexport const CATEGORY_DELIMITER  = 'delimiter';\nexport const CATEGORY_SYMBOL     = 'symbol';\nexport const CATEGORY_SPACE      = 'space';\nexport const CATEGORY_TEXT       = 'text';\n\n// Internal use only\nexport const CATEGORY_LINEBREAK  = 'lb';\n","/**\n * Checks if the given subject is an object or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is an object, or otherwise `false`.\n */\nexport function isObject<T extends object>( subject: any ): subject is T {\n  return subject !== null && typeof subject === 'object';\n}\n\n/**\n * Checks if the given subject is an array or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is an array, or otherwise `false`.\n */\nexport function isArray<T>( subject: any ): subject is T[] {\n  return Array.isArray( subject );\n}\n\n/**\n * Checks if the given subject is a function or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is a function, or otherwise `false`.\n */\nexport function isFunction( subject: any ): subject is ( ...args: any[] ) => any {\n  return typeof subject === 'function';\n}\n\n/**\n * Checks if the given subject is a string or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is a string, or otherwise `false`.\n */\nexport function isString( subject: any ): subject is string {\n  return typeof subject === 'string';\n}\n\n/**\n * Checks if the given subject is `undefined` or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is `undefined`, or otherwise `false`.\n */\nexport function isUndefined( subject: any ): subject is undefined {\n  return typeof subject === 'undefined';\n}\n\n/**\n * Checks if the given subject is an HTMLElement instance or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is an HTMLElement instance, or otherwise `false`.\n */\nexport function isHTMLElement( subject: any ): subject is HTMLElement {\n  return subject instanceof HTMLElement;\n}\n","import { isArray } from '../../type/type';\n\n\n/**\n * Push the provided value to an array only if the value is not an array.\n *\n * @param value - A value to push.\n *\n * @return An array containing the value, or the value itself if it is already an array.\n */\nexport function toArray<T>( value: T | T[] ): T[] {\n  return isArray<T>( value ) ? value : [ value ];\n}\n","import { toArray } from '../../array';\n\n\n/**\n * Adds classes to the element.\n *\n * @param elm     - An element to add classes to.\n * @param classes - Classes to add.\n */\nexport function addClass( elm: HTMLElement, classes: string | string[] ): void {\n  toArray( classes ).forEach( name => {\n    if ( name ) {\n      elm.classList.add( name );\n    }\n  } );\n}\n","import { toArray } from '../../array';\n\n\n/**\n * Appends children to the parent element.\n *\n * @param parent   - A parent element.\n * @param children - A child or children to append to the parent.\n */\nexport function append( parent: HTMLElement, children: Node | Node[] ): void {\n  children = toArray<Node>( children );\n\n  for ( let i = 0; i < children.length; i++ ) {\n    parent.appendChild( children[ i ] );\n  }\n}\n","/**\n * Iterates over the provided object by own enumerable keys with calling the iteratee function.\n *\n * @param object   - An object to iterate over.\n * @param iteratee - An iteratee function that takes the value and key as arguments.\n *\n * @return A provided object itself.\n */\nexport function forOwn<T extends object>( object: T, iteratee: ( value: T[ keyof T ], key: string ) => void ) {\n  if ( object ) {\n    const keys = Object.keys( object );\n\n    for ( let i = 0; i < keys.length; i++ ) {\n      iteratee( object[ keys[ i ] ], keys[ i ] );\n    }\n  }\n}\n","import { isObject, isUndefined } from '../../type/type';\nimport { forOwn } from '../forOwn/forOwn';\n\n\n/**\n * Assign U to T.\n *\n * @typeParam T - An object to assign to.\n * @typeParam U - An object to assign.\n *\n * @return An assigned object type.\n */\nexport type Assign<T, U> = Omit<T, keyof U> & U;\n\nexport function assign<T extends object>( object: T ): T;\n\n// There is a way to type arguments recursively, but these fixed definitions are enough for this project.\nexport function assign<T extends object, U extends object>( object: T, source: U ): Assign<T, U>;\n\nexport function assign<T extends object, U1 extends object, U2 extends object>(\n  object: T, source1: U1, source2: U2\n): Assign<Assign<T, U1>, U2>;\n\nexport function assign<T extends object, U1 extends object, U2 extends object, U3 extends object>(\n  object: T, source1: U1, source2: U2, source3: U3\n): Assign<Assign<Assign<T, U1>, U2>, U3>;\n\n/**\n * Assigns all own enumerable properties of all source objects to the provided object.\n * `undefined` in source objects will be skipped.\n *\n * @param object  - An object to assign properties to.\n * @param sources - Objects to assign properties from.\n *\n * @return An object assigned properties of the sources to.\n */\nexport function assign<T extends object, U extends object>( object: T, ...sources: U[] ): any {\n  sources.forEach( source => {\n    if ( isObject( source ) ) {\n      forOwn( source, ( value, key ) => {\n        if ( ! isUndefined( source[ key ] ) ) {\n          object[ key ] = source[ key ];\n        }\n      } );\n    }\n  } );\n\n  return object;\n}\n","import { forOwn } from '../../object';\nimport { isObject, isString } from '../../type/type';\n\n\nexport function attr( elm: Element, attrs: string ): string;\nexport function attr( elm: Element, attrs: Record<string, string | number | boolean> ): void;\n\n/**\n * Sets new attributes to the passed element if the `attrs` is an object literal,\n * or gets an attribute value from it if the `attrs` is a string.\n *\n * @param elm   - An element to set or get an attribute.\n * @param attrs - An attribute name as a string or new attributes as an object literal.\n */\nexport function attr( elm: Element, attrs: string | Record<string, string | number | boolean> ): string | void {\n  if ( isString( attrs ) ) {\n    return elm.getAttribute( attrs ) || '';\n  }\n\n  if ( isObject( attrs ) ) {\n    forOwn( attrs, ( value, key ) => {\n      elm.setAttribute( key, String( value ) );\n    } );\n  }\n}\n","/**\n * Returns an element that matches the provided selector.\n *\n * @param selector - A selector.\n * @param parent   - Optional. A parent element to start searching elements from.\n *\n * @return A found element or `null`.\n */\nexport function query<E extends Element = HTMLElement>(\n  selector: string,\n  parent: HTMLElement | Document = document\n): E | null {\n  return parent.querySelector<E>( selector );\n}\n","import { forOwn } from '../../object';\n\n\n/**\n * Applies inline styles to the provided element by an object literal.\n *\n * @param elm    - An element to apply styles to.\n * @param styles - An object literal with styles.\n */\nexport function styles( elm: HTMLElement, styles: Record<string, string | number> ): void {\n  forOwn( styles, ( value, key ) => {\n    elm.style[ key ] = String( value );\n  } );\n}\n","/**\n * Returns an open tag with provided classes.\n *\n * @param classes - Classes.\n * @param tag     - Optional. A tag name.\n */\nexport function tag( classes: string[], tag?: string ): string {\n  return `<${ tag || 'div' } class=\"${ classes.join( ' ' ) }\">`;\n}\n","import { isUndefined } from '../../type/type';\n\n\nexport function text( node: Node ): string;\nexport function text( node: Node, text: string ): void;\n\n/**\n * Sets or gets a text content of the provided node.\n *\n * @param node - A node to get or set a text.\n * @param text - Optional. A text to set.\n */\nexport function text( node: Node, text?: string ): string | void {\n  if ( isUndefined( text ) ) {\n    return node.textContent;\n  }\n\n  node.textContent = text;\n}\n","/**\n * Throws an error if the provided condition is falsy.\n *\n * @param condition - If falsy, an error is thrown.\n * @param message   - Optional. A message for the error.\n */\nexport function assert( condition: any, message = '' ): void {\n  if ( ! condition ) {\n    throw new Error( message );\n  }\n}\n","/**\n * The project code name.\n *\n * @since 0.0.1\n */\nexport const PROJECT_CODE = 'ryuseilight';\n\n/**\n * The abbreviated project code.\n *\n * @since 0.0.1\n */\nexport const PROJECT_CODE_SHORT = 'rl';\n","import { MapEntry } from '../types';\nimport { find } from '../find/find';\n\n\n/**\n * Insert entries before the reference entry specified by the `ref`.\n * If the reference is not found, a new entry is created.\n *\n * @param map     - A map to insert values to.\n * @param ref     - A reference key.\n * @param entries - entries to insert.\n */\nexport function before<T extends any>( map: MapEntry<T>[], ref: string, entries: MapEntry<T>[] ): void {\n  const index = find( map, ref );\n\n  if ( index > -1 ) {\n    map.splice( index, 0, ...entries );\n  } else {\n    map.push( ...entries );\n  }\n}\n","import { MapEntry } from '../types';\n\n\n/**\n * Finds the provided key from a map and returns its index.\n *\n * @param map - A map to search in.\n * @param key - A key to search for.\n *\n * @return An index if found, or `-1` otherwise.\n */\nexport function find<T extends any>( map: MapEntry<T>[], key: string ): number {\n  for ( let i = 0; i < map.length; i++ ) {\n    if ( map[ i ][ 0 ] === key ) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n","/**\n * Checks if the string starts with the `char` or not.\n *\n * @param string - A string to check.\n * @param char   - A character.\n *\n * @return `true` if the string starts with the `char`, or otherwise `false`.\n */\nexport function startsWith( string: string, char: string ): boolean {\n  return string.charAt( 0 ) === char;\n}\n","import { Language, Token, TokenInfo, Tokenizer } from '../../types';\nimport { LINE_BREAK } from '../../constants/characters';\nimport { CATEGORY_LINEBREAK, CATEGORY_TEXT } from '../../constants/categories';\nimport { assert, forOwn, isUndefined, startsWith } from '../../utils';\n\n\n/**\n * Checks if the RegExp supports the sticky flag or not.\n */\nconst isStickySupported = ! isUndefined( /x/.sticky );\n\n/**\n * The class for creating a simple lexer by a Language object.\n *\n * @since 0.0.1\n */\nexport class Lexer {\n  /**\n   * Holds the Language object.\n   */\n  readonly language: Language;\n\n  /**\n   * Stores lines.\n   */\n  protected lines: Token[][];\n\n  /**\n   * Indicates the current line index.\n   */\n  protected index: number;\n\n  /**\n   * The depth of the state.\n   */\n  protected depth;\n\n  /**\n   * Limits the number of lines.\n   */\n  protected limit;\n\n  /**\n   * Turned to be `true` if the tokenization is manually aborted.\n   */\n  protected aborted;\n\n  /**\n   * The Lexer constructor.\n   *\n   * @param language - A Language object.\n   */\n  constructor( language: Language ) {\n    this.language = language;\n    this.init( language );\n  }\n\n  /**\n   * Initializes the language object.\n   *\n   * @param language - A Language object to initialize.\n   */\n  protected init( language: Language ): void {\n    forOwn( language.grammar, ( tokenizers, key ) => {\n      language.grammar[ key ] = this.merge( language, tokenizers );\n    } );\n\n    forOwn( language.use, this.init.bind( this ) );\n  }\n\n  /**\n   * Includes tokenizers required by `#` annotation and flatten them.\n   *\n   * @param language   - A language object.\n   * @param tokenizers - Tokenizers.\n   *\n   * @return Merged tokenizers.\n   */\n  protected merge( language: Language, tokenizers: Tokenizer[] ): Tokenizer[] {\n    const merged = [];\n\n    for ( let i = 0; i < tokenizers.length; i++ ) {\n      const tokenizer = tokenizers[ i ];\n      const [ category, regexp ] = tokenizers[ i ];\n\n      if ( startsWith( category, '#' ) && ! regexp ) {\n        merged.push( ...this.merge( language, language.grammar[ category.slice( 1 ) ] ) );\n      } else {\n        const flags = regexp.toString().match( /[gimsy]*$/ )[ 0 ].replace( /[gy]/g, '' );\n        let source = regexp.source + ( isStickySupported ? '' : '|()' );\n\n        forOwn( language.source, ( replacement, key ) => {\n          source = source.replace( new RegExp( `%${ key }`, 'g' ), replacement.source );\n        } );\n\n        tokenizer[ 1 ] = new RegExp( source, ( isStickySupported ? 'y' : 'g' ) + flags );\n        merged.push( tokenizer );\n      }\n    }\n\n    return merged;\n  }\n\n  /**\n   * Parses the text by the provided language and tokenizers.\n   *\n   * @param text       - A text to tokenize.\n   * @param language   - A Language object.\n   * @param tokenizers - An array with tokenizers.\n   * @param state      - Optional. The current state name.\n   *\n   * @return An index of the text where the handling ends.\n   */\n  protected parse( text: string, language: Language, tokenizers: Tokenizer[], state: string ): number {\n    let index    = 0;\n    let position = 0;\n\n    this.depth++;\n\n    main:\n    while ( index < text.length && ! this.aborted ) {\n      for ( let i = 0; i < tokenizers.length; i++ ) {\n        const tokenizer = tokenizers[ i ];\n        const [ , regexp, action ] = tokenizer;\n\n        regexp.lastIndex = index;\n\n        const match = regexp.exec( text );\n\n        if ( ! match || ! match[ 0 ] ) {\n          continue;\n        }\n\n        if ( position < index ) {\n          this.push( [ CATEGORY_TEXT, text.slice( position, index ) ], language, state );\n        }\n\n        if ( action === '@back' ) {\n          position = index;\n          break main;\n        }\n\n        const offset = this.handle( match, language, tokenizer, state );\n        index += offset || 1;\n        position = index;\n\n        if ( action === '@break' ) {\n          break main;\n        }\n\n        continue main;\n      }\n\n      index++;\n    }\n\n    if ( position < index ) {\n      this.push( [ CATEGORY_TEXT, text.slice( position ) ], language, state );\n    }\n\n    this.depth--;\n\n    return index;\n  }\n\n  /**\n   * Pushes the provided token to the lines array.\n   *\n   * @param token    - A token to push.\n   * @param language - A Language object.\n   * @param state    - A state name.\n   */\n  protected push( token: Token, language: Language, state: string ): void {\n    const { depth } = this;\n    const [ category, text ] = token;\n    const start = this.index;\n\n    let index = 0;\n    let from  = 0;\n\n    while ( index > -1 && ! this.aborted ) {\n      index = text.indexOf( LINE_BREAK, from );\n\n      const line  = this.lines[ this.index ];\n      const empty = from === index && ! line.length;\n      const code  = empty ? LINE_BREAK : text.slice( from, index < 0 ? undefined : index );\n      const info  = { depth, language: language.id, state } as TokenInfo;\n\n      if ( code ) {\n        if ( category !== CATEGORY_TEXT ) {\n          info.head     = index > -1 && ! from;\n          info.tail     = index < 0 && !! from;\n          info.split    = index > -1 || !! from;\n          info.distance = this.index - start;\n        }\n\n        line.push( [ category === CATEGORY_TEXT && empty ? CATEGORY_LINEBREAK : category, code, info ] );\n      }\n\n      if ( index > -1 ) {\n        this.index++;\n        this.aborted = this.limit && this.index >= this.limit;\n\n        if ( ! this.aborted ) {\n          from = index + 1;\n          this.lines[ this.index ] = [];\n        }\n      }\n    }\n  }\n\n  /**\n   * Handles the matched text.\n   *\n   * @param match     - A matched result.\n   * @param language  - A Language object.\n   * @param tokenizer - A tokenizer that has been matched with the text.\n   * @param state     - A state name.\n   *\n   * @return An index of the text where the handling ends.\n   */\n  protected handle( match: RegExpExecArray, language: Language, tokenizer: Tokenizer, state: string ): number {\n    const [ category ] = tokenizer;\n\n    if ( ! category ) {\n      return 0;\n    }\n\n    let [ text ] = match;\n\n    if ( tokenizer[ 3 ] === '@debug' ) {\n      // eslint-disable-next-line\n      console.log( text, tokenizer );\n    }\n\n    if ( startsWith( category, '@' ) ) {\n      assert( language.use );\n\n      const lang = language.use[ category.slice( 1 ) ];\n      assert( lang );\n\n      return this.parse( text, lang, lang.grammar.main, category );\n    }\n\n    if ( startsWith( category, '#' ) ) {\n      const tokenizers = language.grammar[ category.slice( 1 ) ];\n      assert( tokenizers );\n\n      if ( tokenizer[ 2 ] === '@rest' ) {\n        text = match.input.slice( match.index );\n      }\n\n      return this.parse( text, language, tokenizers, category );\n    }\n\n    this.push( [ category, text ], language, state );\n    return text.length;\n  }\n\n  /**\n   * Tokenizes the text by the current language.\n   *\n   * @param text  - A text to tokenize.\n   * @param limit - Optional. Limits the number of lines.\n   *\n   * @return An array with tokens.\n   */\n  tokenize( text: string, limit?: number ): Token[][] {\n    this.lines   = [ [] ];\n    this.index   = 0;\n    this.depth   = -1;\n    this.limit   = limit || 0;\n    this.aborted = false;\n\n    this.parse( text, this.language, this.language.grammar.main, '#main' );\n\n    return this.lines;\n  }\n}\n","import { PROJECT_CODE, PROJECT_CODE_SHORT } from './project';\n\n\nexport const ROOT      = PROJECT_CODE;\nexport const CONTAINER = `${ PROJECT_CODE_SHORT }__container`;\nexport const BODY      = `${ PROJECT_CODE_SHORT }__body`;\nexport const CODE      = `${ PROJECT_CODE_SHORT }__code`;\nexport const LINE      = `${ PROJECT_CODE_SHORT }__line`;\nexport const TOKEN     = `${ PROJECT_CODE_SHORT }__token`;\nexport const ACTIVE    = 'is-active';\n","import { AnyFunction } from '../types';\n\n\n/**\n * The class for providing the very simple event bus.\n *\n * @private\n * @since 0.0.1\n */\nexport class EventBus {\n  /**\n   * Holds handlers.\n   */\n  protected handlers = {};\n\n  /**\n   * Attaches a handler.\n   *\n   * @param event    - An event name.\n   * @param callback - A callback function to register.\n   * @param priority - Optional. A priority number for the order in which the callbacks are invoked.\n   */\n  on( event: string, callback: AnyFunction, priority = 10 ): void {\n    const handlers = ( this.handlers[ event ] = this.handlers[ event ] || [] );\n    handlers.push( { callback, priority } );\n    handlers.sort( ( handler1, handler2 ) => handler1.priority - handler2.priority );\n  }\n\n  /**\n   * Emits an event.\n   *\n   * @param event - An event name.\n   * @param args  - Optional. Any number of arguments to pass to callbacks.\n   */\n  emit( event, ...args ): void {\n    ( this.handlers[ event ] || [] ).forEach( handler => {\n      handler.callback( ...args );\n    } );\n  }\n\n  /**\n   * Destroys the event bus.\n   */\n  destroy(): void {\n    this.handlers = {};\n  }\n}\n","import { BODY, CODE, CONTAINER, LINE, ROOT, TOKEN } from '../../constants/classes';\nimport { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { EventBus } from '../../event/EventBus';\nimport { Component, LanguageInfo, Options, Token } from '../../types';\nimport { escapeHtml, forOwn, tag } from '../../utils';\n\n\n/**\n * Stores all Component functions.\n */\nconst Components: Record<string, Component> = {};\n\n/**\n * The class for highlighting code via provided tokens.\n *\n * @since 0.0.1\n */\nexport class Renderer {\n  /**\n   * Adds components.\n   *\n   * @param components - An object literal with Component functions.\n   */\n  static compose( components: Record<string, Component> ): void {\n    forOwn( components, ( Component, name ) => {\n      Components[ name ] = Component;\n    } );\n  }\n\n  /**\n   * Holds lines with tokens.\n   */\n  readonly lines = [];\n\n  /**\n   * Holds the language info.\n   */\n  readonly info: LanguageInfo;\n\n  /**\n   * Holds the root element if provided.\n   */\n  readonly root: HTMLElement | undefined;\n\n  /**\n   * Holds options.\n   */\n  readonly options: Options;\n\n  /**\n   * Holds the EventBus instance.\n   */\n  readonly event: EventBus = new EventBus();\n\n  /**\n   * The Renderer constructor.\n   *\n   * @param lines   - Lines with tokens to render.\n   * @param info    - The language info object.\n   * @param root    - Optional. A root element to highlight.\n   * @param options - Options.\n   */\n  constructor( lines: Token[][], info: LanguageInfo, root?: HTMLElement, options: Options = {} ) {\n    this.lines   = lines;\n    this.info    = info;\n    this.root    = root;\n    this.options = options;\n\n    this.init();\n  }\n\n  /**\n   * Initializes the instance.\n   */\n  protected init(): void {\n    const { lines } = this;\n\n    if ( lines.length ) {\n      const tokens = lines[ lines.length - 1 ];\n\n      if ( ! tokens.length || ( tokens.length === 1 && ! tokens[ 0 ][ 1 ].trim() ) ) {\n        // Removes the last empty line.\n        lines.pop();\n      }\n    }\n\n    forOwn( Components, Component => {\n      Component( this );\n    } );\n\n    this.event.emit( 'mounted' );\n  }\n\n  /**\n   * Renders lines as HTML.\n   *\n   * @param append - A function to add fragments to the HTML string.\n   *\n   * @return A rendered HTML string.\n   */\n  protected renderLines( append: ( fragment: string ) => void ): void {\n    const event   = this.event;\n    const tagName = this.options.span ? 'span' : 'code';\n\n    for ( let i = 0; i < this.lines.length; i++ ) {\n      const tokens  = this.lines[ i ];\n      const classes = [ LINE ];\n\n      event.emit( 'line:open', append, classes, i );\n      append( tag( classes ) );\n\n      for ( let j = 0; j < tokens.length; j++ ) {\n        const token      = tokens[ j ];\n        const categories = token[ 0 ].split( '.' );\n        const className  = `${ PROJECT_CODE_SHORT }__${ categories[ 0 ] }`;\n        const modifiers  = categories.slice( 1 ).map( sub => `${ className }--${ sub }` );\n        const classes    = [ TOKEN, className ].concat( modifiers );\n\n        event.emit( 'token', token, classes );\n        append( `${ tag( classes, tagName ) }${ escapeHtml( token[ 1 ] ) }</${ tagName }>` );\n      }\n\n      append( '</div>' );\n      event.emit( 'line:closed', append, i );\n    }\n  }\n\n  /**\n   * Returns all lines and wrapper elements.\n   *\n   * @param pre - Whether to wrap elements by `pre` or not.\n   *\n   * @return An HTML string.\n   */\n  html( pre: boolean ): string {\n    const { event } = this;\n    const closeTag  = '</div>';\n    let html  = '';\n\n    const append = ( fragment: string ) => { html += fragment };\n\n    if ( pre ) {\n      html += tag( [ `${ ROOT } ${ ROOT }--${ this.info.id }` ], 'pre' );\n    }\n\n    const containerClasses = [ CONTAINER ];\n    event.emit( 'open', append, containerClasses );\n    html += tag( containerClasses );\n\n    const bodyClasses = [ `${ BODY }${ this.options.wrap ? ` ${ BODY }--wrap` : '' }` ];\n    event.emit( 'body:open', append, bodyClasses );\n    html += tag( bodyClasses );\n\n    event.emit( 'code:open', append );\n    html += tag( [ CODE ] );\n    this.renderLines( append );\n    html += closeTag; // code\n\n    event.emit( 'body:close', append );\n    html += closeTag; // body\n\n    event.emit( 'close', append );\n    html += closeTag; // container\n\n    event.emit( 'closed', append );\n\n    if ( pre ) {\n      html += `</pre>`;\n    }\n\n    return html;\n  }\n\n  /**\n   * Destroys the instance.\n   */\n  destroy(): void {\n    this.event.emit( 'destroy' );\n    this.event.destroy();\n  }\n}\n","/**\n * Converts essential HTML special characters to HTML entities.\n *\n * @param string - A string to escape.\n *\n * @return An escaped string.\n */\nexport function escapeHtml( string: string ): string {\n  return string.replace( /&/g, '&amp;' ).replace( /</g, '&lt;' );\n}\n","export const REGEXP_FLOAT = /\\d+\\.?\\d*|\\d*\\.?\\d+/;\n\nexport const REGEXP_NUMBER = /[+-]?(\\d+\\.?\\d*|\\d*\\.?\\d+)([eE][+-]?\\d+)?/;\n\nexport const REGEXP_BOOLEAN = /\\b(?:true|false)\\b/;\n\nexport const REGEXP_BRACKET = /[[\\]{}()]/;\n\nexport const REGEXP_SPACE = /[ \\t]+/;\n\nexport const REGEXP_QUOTE = /'(?:\\\\'|.)*?'/;\n\nexport const REGEXP_DOUBLE_QUOTE = /\"(?:\\\\\"|.)*?\"/;\n\nexport const REGEXP_MULTILINE_COMMENT = /\\/\\*[\\s\\S]*?(\\*\\/|$)/;\n\nexport const REGEXP_SLASH_COMMENT = /\\/\\/.*/;\n\nexport const REGEXP_GENERAL_KEYWORDS = /\\b(?:break|catch|class|continue|do|else|extends|finally|for|function|if|implements|in|instanceof|interface|new|null|return|throw|try|while)\\b/;\n","import { Language } from '../../types';\nimport {\n  CATEGORY_BRACKET,\n  CATEGORY_COMMENT,\n  CATEGORY_FUNCTION,\n  CATEGORY_KEYWORD,\n  CATEGORY_NUMBER,\n  CATEGORY_OPERATOR,\n  CATEGORY_PROPERTY,\n  CATEGORY_SELECTOR,\n  CATEGORY_SPACE,\n  CATEGORY_STRING,\n  CATEGORY_DELIMITER,\n  CATEGORY_TAG,\n  CATEGORY_ATRULE,\n} from '../../constants/categories';\nimport { REGEXP_MULTILINE_COMMENT, REGEXP_SPACE } from '../../constants/regexp';\n\n\n/**\n * Returns the CSS language definition.\n *\n * @return A Language object.\n */\nexport function css(): Language {\n  return {\n    id  : 'css',\n    name: 'CSS',\n\n    grammar: {\n      main: [\n        [ '#common' ],\n\n        // An atrule without a block\n        [ '#findSingleAtrule' ],\n\n        // Blocks including atrules\n        [ '#findBlock' ],\n      ],\n\n      findBlock: [\n        [ '#block', /[^ \\t\\r\\n;{}][^;{}]*{.*?}/s, '@rest' ],\n      ],\n\n      findSingleAtrule: [\n        [ '#atrule', /@[^{;]+?;/s ],\n      ],\n\n      // Finds atrules before { and ;\n      findAtrule: [\n        [ '#atrule', /@[^{;]*?(?=[{;])/s ],\n      ],\n\n      // May not start with digits\n      findSelector: [\n        [ '#selector', /[^ \\t\\r\\n{};].*?(?={)/s ],\n      ],\n\n      common: [\n        [ CATEGORY_STRING, /(['\"]).*?[^\\\\]\\1/s ],\n        [ CATEGORY_COMMENT, REGEXP_MULTILINE_COMMENT ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n\n      block: [\n        [ '#inner', /{/, '@rest' ],\n        [ CATEGORY_BRACKET, /}/, '@break' ],\n        [ '#findAtrule' ],\n        [ '#findSelector' ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n\n      inner: [\n        [ CATEGORY_BRACKET, /{/ ],\n        [ '#common' ],\n        [ '#findBlock' ],\n        [ '#props' ],\n        [ '#findAtrule' ],\n        [ '', /}/, '@back' ],\n      ],\n\n      atrule: [\n        [ '#common' ],\n        [ '#url', /\\burl\\(/, '@rest' ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n        [ CATEGORY_ATRULE, /[^\\s();]+/ ],\n        [ CATEGORY_DELIMITER, /[:;,]/ ],\n        [ '#paren', /\\(/, '@rest' ],\n      ],\n\n      paren: [\n        [ CATEGORY_BRACKET, /^\\(/ ],\n        [ '#common' ],\n        [ '#paren', /\\(/, '@rest' ],\n        [ CATEGORY_BRACKET, /\\)/, '@break' ],\n        [ '#props' ],\n      ],\n\n      selector: [\n        [ '#common' ],\n        [ CATEGORY_OPERATOR, /[>+~]/ ],\n        [ CATEGORY_BRACKET, /[[\\]()]/ ],\n        [ CATEGORY_DELIMITER, /=/ ],\n        [ CATEGORY_SELECTOR, /::?\\S+/ ],\n        [ CATEGORY_SELECTOR, /[\\W\\d]\\S+/ ],\n        [ CATEGORY_TAG, /\\b[a-z]+|\\*/i ],\n        [ CATEGORY_SELECTOR, /\\S+/ ],\n      ],\n\n      url: [\n        [ '#common' ],\n        [ CATEGORY_FUNCTION, /^url/ ],\n        [ CATEGORY_BRACKET, /\\(/ ],\n        [ CATEGORY_STRING, /[^)]+/ ],\n        [ CATEGORY_BRACKET, /\\)/, '@break' ],\n      ],\n\n      props: [\n        [ CATEGORY_PROPERTY, /[a-z0-9-_\\xA0-\\uFFFF]+(?=:)/i ],\n        [ '#url', /\\burl\\(/, '@rest' ],\n        [ CATEGORY_FUNCTION, /\\b[\\w-]+(?=\\()\\b/ ],\n        [ CATEGORY_KEYWORD, /!important|\\b(?:initial|inherit|unset)/ ],\n        [ CATEGORY_PROPERTY, /[a-z0-9-]+(?=:)/ ],\n        [ CATEGORY_NUMBER, /#([0-9a-f]{6}|[0-9a-f]{3})/i ],\n        [ CATEGORY_NUMBER, /\\bU\\+[0-9a-f?-]+/i ],\n        [ CATEGORY_NUMBER, /[+-]?(\\d+\\.?\\d*|\\d*\\.?\\d+)/ ],\n        [ CATEGORY_DELIMITER, /[:;,]/ ],\n        [ '#paren', /\\(/, '@rest' ],\n        [ CATEGORY_BRACKET, /[[\\])]/ ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n    },\n  };\n}\n","import {\n  REGEXP_BOOLEAN, REGEXP_BRACKET, REGEXP_DOUBLE_QUOTE, REGEXP_GENERAL_KEYWORDS, REGEXP_MULTILINE_COMMENT,\n  REGEXP_NUMBER, REGEXP_QUOTE, REGEXP_SLASH_COMMENT, REGEXP_SPACE,\n} from '../../constants/regexp';\nimport { Language } from '../../types';\nimport {\n  CATEGORY_DELIMITER, CATEGORY_DECORATOR, CATEGORY_KEYWORD, CATEGORY_REGEXP, CATEGORY_STRING,\n  CATEGORY_OPERATOR, CATEGORY_COMMENT, CATEGORY_CLASS, CATEGORY_FUNCTION, CATEGORY_BOOLEAN,\n  CATEGORY_IDENTIFIER, CATEGORY_NUMBER, CATEGORY_BRACKET, CATEGORY_SPACE,\n} from '../../constants/categories';\n\n\n/**\n * Returns the JavaScript language definition.\n *\n * @return A Language object.\n */\nexport function javascript(): Language {\n  return {\n    id   : 'javascript',\n    name : 'JavaScript',\n    alias: [ 'js' ],\n\n    source: {\n      func: /[_$a-z\\xA0-\\uFFFF][_$a-z0-9\\xA0-\\uFFFF]*/,\n    },\n\n    grammar: {\n      main: [\n        [ CATEGORY_STRING, REGEXP_QUOTE ],\n        [ CATEGORY_STRING, REGEXP_DOUBLE_QUOTE ],\n        [ '#backtick', /`/, '@rest' ],\n        [ CATEGORY_COMMENT, REGEXP_MULTILINE_COMMENT ],\n        [ CATEGORY_COMMENT, REGEXP_SLASH_COMMENT ],\n        [ CATEGORY_REGEXP, /\\/(\\[.*[^\\\\]?]|\\\\\\/|.)+?\\/[gimsuy]*/ ],\n        [ CATEGORY_KEYWORD, REGEXP_GENERAL_KEYWORDS ],\n        [ CATEGORY_KEYWORD, /\\b(?:as|async|await|case|catch|const|debugger|default|delete|enum|export|from|import|let|package|private|protected|public|super|switch|static|this|typeof|undefined|var|void|with|yield)\\b/ ],\n        [ CATEGORY_KEYWORD, /\\b((get|set)(?=\\s+%func))/i ],\n        [ CATEGORY_CLASS, /\\b[A-Z][\\w$]*\\b/ ],\n        [ CATEGORY_FUNCTION, /%func(?=\\s*\\()/i ],\n        [ CATEGORY_BOOLEAN, REGEXP_BOOLEAN ],\n        [ CATEGORY_DECORATOR, /@[^\\s(@]+/ ],\n        [ CATEGORY_IDENTIFIER, /\\b[a-z_$][\\w$]*\\b/ ],\n        [ CATEGORY_NUMBER, REGEXP_NUMBER ],\n        [ CATEGORY_OPERATOR, /=>/ ],\n        [ CATEGORY_OPERATOR, /\\+[+=]?|-[-=]?|\\*\\*?=?|[/%^]=?|&&?=?|\\|\\|?=?|\\?\\??=?|<<?=?|>>>=?|>>?=?|[!=]=?=?|[~:^]/ ],\n        [ CATEGORY_BRACKET, REGEXP_BRACKET ],\n        [ CATEGORY_DELIMITER, /[;.,]+/ ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n\n      backtick: [\n        [ CATEGORY_STRING, /^`/ ],\n        [ CATEGORY_STRING, /(\\$[^{]|\\\\[$`]|[^`$])+/ ],\n        [ '#expression', /\\${/, '@rest' ],\n        [ CATEGORY_STRING, /`/, '@break' ],\n      ],\n\n      expression: [\n        [ CATEGORY_DELIMITER, /^\\${/ ],\n        [ CATEGORY_DELIMITER, /}/, '@break' ],\n        [ '#main' ],\n      ],\n    },\n  };\n}\n","import {\n  CATEGORY_ATTRIBUTE,\n  CATEGORY_BRACKET,\n  CATEGORY_CDATA,\n  CATEGORY_COMMENT,\n  CATEGORY_DELIMITER,\n  CATEGORY_ENTITY,\n  CATEGORY_PROLOG,\n  CATEGORY_SPACE,\n  CATEGORY_TAG,\n  CATEGORY_TAG_CLOSE,\n  CATEGORY_VALUE,\n} from '../../constants/categories';\nimport { REGEXP_SPACE } from '../../constants/regexp';\nimport { Language, Tokenizer } from '../../types';\nimport { css } from '../css/css';\nimport { javascript } from '../javascript/javascript';\n\n\n/**\n * The HTML language options.\n *\n * @since 0.0.12\n */\nexport interface HtmlOptions {\n  /**\n   * The language for tokenizing script blocks.\n   */\n  script?: () => Language;\n\n  /**\n   * The language for tokenizing style blocks.\n   */\n  style?: () => Language;\n}\n\n/**\n * Returns the HTML language definition.\n *\n * @param options - Optional. Options.\n *\n * @return A Language object.\n */\nexport function html( options: HtmlOptions = {} ): Language {\n  const script = ( options.script || javascript )();\n  const style  = ( options.style || css )();\n  const cdata  = [ CATEGORY_CDATA, /<!\\[CDATA\\[.*]]>/is ] as Tokenizer;\n\n  // Embedded scripts or styles may contain CDATA sections.\n  script.grammar.main.unshift( cdata );\n  style.grammar.main.unshift( cdata );\n\n  return {\n    id   : 'html',\n    alias: [ 'markup' ],\n    name : 'HTML',\n    use  : { script, style },\n\n    grammar: {\n      main: [\n        [ CATEGORY_COMMENT, /<!--.*?-->/s ],\n        [ CATEGORY_PROLOG, /<!DOCTYPE.*?>/is ],\n        cdata,\n        [ '#script', /<script.*?>.*?<\\/script>/s ],\n        [ '#style', /<style.*?>.*?<\\/style>/s ],\n        [ '#tag', /<.*?>/s ],\n        [ CATEGORY_ENTITY, /&[\\da-z]+;|&#\\d+;/i ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n\n      script: [\n        [ '#tag', /^<script.*?>/s ],\n        cdata,\n        [ '@script', /.+(?=<\\/script>)/s ],\n        [ '#tag', /<\\/script>/ ],\n      ],\n\n      style: [\n        [ '#tag', /^<style.*?>/s ],\n        [ '@style', /.+(?=<\\/style>)/s ],\n        [ '#tag', /<\\/style>/ ],\n      ],\n\n      tag: [\n        [ '#closeTag', /<\\/.+>/ ],\n        [ '#tagContent' ],\n      ],\n\n      closeTag: [\n        [ CATEGORY_TAG_CLOSE, /[^\\s/<>\"'=]+/ ],\n        [ '#tagContent' ],\n      ],\n\n      tagContent: [\n        [ '#attr', /[ \\t\\r\\n]+.+(?=[ \\t\\r\\n/>])/s ],\n        [ CATEGORY_TAG, /[^\\s/<>\"'=]+/ ],\n        [ CATEGORY_BRACKET, /[<>]/ ],\n        [ CATEGORY_DELIMITER, /[/]/ ],\n      ],\n\n      attr: [\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n        [ CATEGORY_VALUE, /(['\"])(\\\\\\1|.)*?\\1/ ],\n        [ CATEGORY_DELIMITER, /[/=]/ ],\n        [ CATEGORY_ATTRIBUTE, /[^\\s/>\"'=]+/ ],\n      ],\n    },\n  };\n}\n","import { Language } from '../../types';\nimport {\n  CATEGORY_ATTRIBUTE, CATEGORY_BRACKET, CATEGORY_CLASS, CATEGORY_SPACE,\n  CATEGORY_DELIMITER, CATEGORY_TAG, CATEGORY_VALUE,\n} from '../../constants/categories';\nimport { REGEXP_SPACE } from '../../constants/regexp';\nimport { assign, before } from '../../utils';\nimport { javascript } from '../javascript/javascript';\n\n\n/**\n * Options for the JSX language definition.\n *\n * @since 0.0.12\n */\ninterface JsxOptions {\n  /**\n   * The base language. The default value is `javascript()`.\n   */\n  base?: () => Language;\n}\n\n/**\n * Returns the JSX language definition.\n *\n * @return A Language object.\n */\nexport function jsx( options: JsxOptions = {} ): Language {\n  const language = assign( ( options.base || javascript )(), {\n    id   : 'jsx',\n    name : 'JSX',\n    alias: [ 'react' ],\n  } );\n\n  const { grammar } = language;\n\n  before( grammar.main, CATEGORY_CLASS, [ [ '#findPairedTag' ], [ '#findSelfClosedTag' ] ] );\n\n  assign( grammar, {\n    // This doesn't pick correct paired tags if nested, but they are incrementally searched later.\n    findPairedTag: [\n      [ '#pairedTag', /(?:<\\s*?(\\w+).*?>.*?<\\/\\1>)|<\\s*?>.*?<\\/>/s, '@rest' ],\n    ],\n\n    // Should not match the closing delimiter inside `{}`, `''` and `\"\"`.\n    findSelfClosedTag: [\n      [ '#selfClosedTag', /<(?:{.*?}|(['\"]).*?\\1|[^>])+?\\/>/s ],\n    ],\n\n    findBracket: [\n      [ '#code', /{/, '@rest' ],\n    ],\n\n    pairedTag: [\n      [ '#openTag', /^</, '@rest' ],\n      [ '#findBracket' ],\n      [ '#findPairedTag' ],\n      [ '#findSelfClosedTag' ],\n      [ '#tagName', /<\\/([\\w][^\\s]*?)?>/, '@break' ],\n      [ CATEGORY_SPACE, REGEXP_SPACE ],\n    ],\n\n    code: [\n      [ CATEGORY_BRACKET, /^{/ ],\n      [ CATEGORY_BRACKET, /}/, '@break' ],\n      [ '#findBracket' ],\n      [ '#main' ],\n    ],\n\n    selfClosedTag: [\n      [ '#openTag', /^</, '@rest' ],\n    ],\n\n    openTag: [\n      [ '#tagName', /<\\s*[^\\s/>\"'=]*/ ],\n      [ '#findBracket' ],\n      [ CATEGORY_ATTRIBUTE, /[^\\s/>\"'=]+/ ],\n      [ CATEGORY_VALUE, /(['\"])(\\\\\\1|.)*?\\1/ ],\n      [ CATEGORY_SPACE, REGEXP_SPACE ],\n      [ CATEGORY_DELIMITER, /[/=]/ ],\n      [ CATEGORY_BRACKET, />/, '@break' ],\n    ],\n\n    tagName: [\n      [ CATEGORY_BRACKET, /[<>]/ ],\n      [ CATEGORY_SPACE, REGEXP_SPACE ],\n      [ CATEGORY_DELIMITER, /\\// ],\n      [ CATEGORY_CLASS, /[A-Z][\\w$-]*/ ],\n      [ CATEGORY_TAG, /[^\\s/>\"'=]+/ ],\n    ],\n  } );\n\n  return language;\n}\n","import { Language } from '../../types';\n\n\n/**\n * Returns the None language definition.\n *\n * @return A Language object.\n */\nexport function none(): Language {\n  return {\n    id     : 'none',\n    name   : '',\n    grammar: { main: [] },\n  };\n}\n","import { Language } from '../../types';\nimport { CATEGORY_PROLOG } from '../../constants/categories';\nimport { assign } from '../../utils';\nimport { html } from '../html/html';\n\n\n/**\n * Returns the XML language definition.\n *\n * @return A Language object.\n */\nexport function xml(): Language {\n  const language = assign( html(), {\n    id   : 'xml',\n    name : 'XML',\n    alias: [],\n  } );\n\n  language.grammar.main.unshift( [ CATEGORY_PROLOG, /<\\?.*?\\?>/s ] );\n\n  return language;\n}\n","import { Language } from '../../types';\nimport { CATEGORY_FUNCTION, CATEGORY_KEYWORD } from '../../constants/categories';\nimport { assign, before } from '../../utils';\nimport { javascript } from '../javascript/javascript';\n\n\n/**\n * Returns the Typescript language definition.\n *\n * @return A Language object.\n */\nexport function typescript(): Language {\n  const language = assign( javascript(), {\n    id   : 'typescript',\n    name : 'TypeScript',\n    alias: [ 'ts' ],\n  } );\n\n  const { grammar } = language;\n  const { main }    = grammar;\n\n  before( main, CATEGORY_KEYWORD, [\n    [\n      CATEGORY_KEYWORD,\n      /\\b(?:declare|keyof|namespace|readonly|type|string|number|boolean|bigint|symbol|object|any|never|unknown|infer|is)\\b/,\n    ],\n  ] );\n\n  before( main, CATEGORY_FUNCTION, [\n    [ '#functions', /([_$a-z\\xA0-\\uFFFF][_$a-z0-9\\xA0-\\uFFFF]*)?(?:<[^>]+?>)?\\s*?\\(/ ],\n  ] );\n\n  assign( grammar, {\n    functions: [\n      [ CATEGORY_FUNCTION, /^[\\w$]+/ ],\n      // Avoid circular references(\"main\" has #functions).\n      ...main.filter( tokenizer => tokenizer[ 0 ] !== '#functions' ),\n    ],\n  } );\n\n  return language;\n}\n","import { REGEXP_BOOLEAN, REGEXP_DOUBLE_QUOTE, REGEXP_SPACE } from '../../constants/regexp';\nimport { Language } from '../../types';\nimport {\n  CATEGORY_BOOLEAN, CATEGORY_BRACKET, CATEGORY_KEYWORD, CATEGORY_NUMBER, CATEGORY_OPERATOR,\n  CATEGORY_PROPERTY, CATEGORY_SPACE, CATEGORY_STRING, CATEGORY_DELIMITER,\n} from '../../constants/categories';\n\n\n/**\n * Returns the JSON language definition.\n *\n * @link https://www.json.org/json-en.html\n *\n * @return A Language object.\n */\nexport function json(): Language {\n  return {\n    id  : 'json',\n    name: 'JSON',\n\n    grammar: {\n      main: [\n        [ CATEGORY_PROPERTY, /\".*?[^\\\\]\"(?=:)/ ],\n        [ CATEGORY_STRING, REGEXP_DOUBLE_QUOTE ],\n        [ CATEGORY_KEYWORD, /\\bnull\\b/ ],\n        [ CATEGORY_NUMBER, /[+-]?(\\d+\\.?\\d*)([eE][+-]?\\d+)?/ ],\n        [ CATEGORY_BRACKET, /[{}[\\]]/ ],\n        [ CATEGORY_BOOLEAN, REGEXP_BOOLEAN ],\n        [ CATEGORY_OPERATOR, /:/ ],\n        [ CATEGORY_DELIMITER, /,/ ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n    },\n  };\n}\n","import { Language } from '../../types';\nimport {\n  CATEGORY_BRACKET, CATEGORY_COMMENT, CATEGORY_FUNCTION, CATEGORY_OPERATOR, CATEGORY_PROPERTY,\n  CATEGORY_SELECTOR, CATEGORY_SPACE, CATEGORY_STRING, CATEGORY_DELIMITER,\n  CATEGORY_TAG, CATEGORY_VARIABLE,\n} from '../../constants/categories';\nimport { REGEXP_MULTILINE_COMMENT, REGEXP_SLASH_COMMENT, REGEXP_SPACE } from '../../constants/regexp';\nimport { assign, before } from '../../utils';\nimport { css } from '../css/css';\n\n\n/**\n * Returns the SCSS language definition.\n *\n * @return A Language object.\n */\nexport function scss(): Language {\n  const language = assign( css(), {\n    id  : 'scss',\n    name: 'SCSS',\n  } );\n\n  const { grammar } = language;\n\n  assign( grammar, {\n    findBlock: [\n      /**\n       * Include: div {}, .class {}, #id {}, * {}, *{}, #{ $variable } {}, .something__#{ $variable } {}\n       * Exclude: #{ variable }: value\n       */\n      [ '#block', /([a-z*-_]|#{[^;]*?}|((#{[^;]*?}|[^\\s{};])(#{[^;]*?}|[^{};#]|#[^{])+?))(?!#){.*?}/si, '@rest' ],\n    ],\n\n    // May contain #{} interpolation\n    findSingleAtrule: [\n      [ '#atrule', /@(#{|[^{;])+?;/s ],\n    ],\n\n    findAtrule: [\n      [ '#atrule', /@(#{|[^{;])*?(?=[{;])/s ],\n    ],\n\n    // May contain #{} interpolation\n    findSelector: [\n      [ '#selector', /[^;]*?[^#](?={)/s, '' ],\n    ],\n\n    findInterp: [\n      [ '#interp', /#{/, '@rest' ],\n    ],\n\n    common: [\n      [ '#string' ],\n      [ CATEGORY_COMMENT, REGEXP_MULTILINE_COMMENT ],\n      [ CATEGORY_COMMENT, REGEXP_SLASH_COMMENT ],\n      [ CATEGORY_DELIMITER, /;/ ],\n      [ CATEGORY_SPACE, REGEXP_SPACE ],\n    ],\n\n    string: [\n      [ '#singleQuote', /'/, '@rest' ],\n      [ '#doubleQuote', /\"/, '@rest' ],\n    ],\n\n    singleQuote: [\n      [ CATEGORY_STRING, /^'/ ],\n      [ '#findInterp' ],\n      [ CATEGORY_STRING, /(\\\\'|#[^{]|[^'#])+/ ],\n      [ CATEGORY_STRING, /'/, '@break' ],\n    ],\n\n    doubleQuote: [\n      [ CATEGORY_STRING, /^\"/ ],\n      [ '#findInterp' ],\n      [ CATEGORY_STRING, /(\\\\\"|#[^{]|[^\"#])+/ ],\n      [ CATEGORY_STRING, /\"/, '@break' ],\n    ],\n\n    selector: [\n      [ '#common' ],\n      [ '#findInterp' ],\n      [ CATEGORY_OPERATOR, /[>+~]/ ],\n      [ CATEGORY_BRACKET, /[[\\]()]/ ],\n      [ CATEGORY_DELIMITER, /=/ ],\n      [ CATEGORY_SELECTOR, /::?\\S+(?=#{)/ ],\n      [ CATEGORY_SELECTOR, /[\\W\\d]\\S+(?=#{)/ ],\n      [ CATEGORY_TAG, /\\b[a-zA-Z]+\\b|\\*/ ],\n      [ CATEGORY_SELECTOR, /([^#\\s]|#[^{\\s])+/ ],\n    ],\n\n    url: [\n      [ '#common' ],\n      [ '#findInterp' ],\n      [ CATEGORY_FUNCTION, /^url/ ],\n      [ CATEGORY_BRACKET, /\\(/ ],\n      [ CATEGORY_STRING, /[^)]+(?=#{)/ ],\n      [ CATEGORY_STRING, /[^)]+/ ],\n      [ CATEGORY_BRACKET, /\\)/, '@break' ],\n    ],\n\n    interp: [\n      [ CATEGORY_DELIMITER, /#{/ ],\n      [ CATEGORY_DELIMITER, /}/, '@break' ],\n      [ '#common' ],\n      [ '#props' ],\n    ],\n  } );\n\n  grammar.inner.unshift( [ '#findInterp' ] );\n\n  before( grammar.atrule, '#url', [ [ '#findInterp' ] ] );\n  before( grammar.props, CATEGORY_PROPERTY, [\n    [ '#findInterp' ],\n    [ CATEGORY_VARIABLE, /\\$[\\w-_]+/ ],\n  ] );\n\n  return language;\n}\n","import { Language } from '../../types';\nimport { assign } from '../../utils';\nimport { xml } from '../xml/xml';\n\n\n/**\n * Returns the XML language definition.\n *\n * @return A Language object.\n */\nexport function svg(): Language {\n  return assign( xml(), {\n    id   : 'svg',\n    name : 'SVG',\n    alias: [],\n  } );\n}\n","import { Language } from '../../types';\nimport { assign } from '../../utils';\nimport { jsx } from '../jsx/jsx';\nimport { typescript } from '../typescript/typescript';\n\n\n/**\n * Returns the TSX language definition.\n *\n * @return A Language object.\n */\nexport function tsx(): Language {\n  return assign( jsx( { base: typescript } ), {\n    id   : 'tsx',\n    name : 'TSX',\n  } );\n}\n","import { Language } from '../../types';\nimport { assign } from '../../utils';\nimport { html, HtmlOptions } from '../html/html';\n\n\n/**\n * The Vue language options.\n *\n * @since 0.0.12\n */\ninterface VueOptions extends HtmlOptions {}\n\n/**\n * Returns the VUE language definition.\n *\n * @return A Language object.\n */\nexport function vue( options: VueOptions = {} ): Language {\n  const language = assign( html( options ), { id: 'vue', name: 'Vue', alias: [] } );\n\n  // Vue uses Mustache syntax for writing code inside tags.\n  language.grammar.main.push( [ '@script', /{{[\\s\\S]*?}}/ ] );\n\n  return language;\n}\n","import { Language, Options, Token } from '../../types';\nimport { Lexer } from '../Lexer/Lexer';\nimport { Renderer } from '../Renderer/Renderer';\nimport { ROOT } from '../../constants/classes';\nimport { ATTRIBUTE_LANGUAGE } from '../../constants/attributes';\nimport { attr, isHTMLElement, text, assert, isString, assign, addClass, toArray } from '../../utils';\nimport { none } from '../../languages';\n\n\n/**\n * Stores all Lexer instances.\n */\nconst lexers: Record<string, Lexer> = {};\n\n/**\n * The class that tokenizes code for syntax highlighting.\n *\n * @since 0.0.1\n */\nexport class RyuseiLight {\n  /**\n   * Registers languages.\n   *\n   * @param languages - A Language object or objects.\n   */\n  static register( languages: Language | Language[] ): void {\n    toArray( languages ).forEach( language => {\n      const { id } = language;\n\n      if ( id && ! lexers[ id ] ) {\n        ( language.alias || [] ).concat( id ).forEach( id => {\n          lexers[ id ] = new Lexer( language );\n        } );\n      }\n    } );\n  }\n\n  /**\n   * Adds components.\n   *\n   * @param components - An object literal with Component functions.\n   */\n  static compose = Renderer.compose;\n\n  /**\n   * Tokenizes the provided string.\n   *\n   * @param code     - A string to tokenize.\n   * @param language - A language ID.\n   * @param limit    - Optional. Limits the (ideal) number of lines.\n   *\n   * @return An array of arrays with tokens as [ string, string ].\n   */\n  static tokenize( code: string, language: string, limit?: number ): Token[][] {\n    return RyuseiLight.getLexer( language ).tokenize( code, limit );\n  }\n\n  /**\n   * Checks if the given language has been already registered or not.\n   *\n   * @param language - A language to check.\n   */\n  static has( language: string ): boolean {\n    return !! lexers[ language ];\n  }\n\n  /**\n   * Returns a registered Lexer instance.\n   * If it's not found, the `none` lexer will be returned.\n   *\n   * @param language - A language name.\n   */\n  protected static getLexer( language: string ) {\n    if ( ! lexers.none ) {\n      RyuseiLight.register( none() );\n    }\n\n    return lexers[ language ] || lexers.none;\n  }\n\n  /**\n   * Holds all renderers.\n   */\n  protected readonly renderers: Renderer[] = [];\n\n  /**\n   * Holds options.\n   */\n  protected readonly options: Options;\n\n  /**\n   * The RyuseiLight constructor.\n   *\n   * @param options  - Optional. Options.\n   */\n  constructor( options?: Options ) {\n    this.options = assign( {}, options );\n  }\n\n  /**\n   * Returns a new Renderer instance.\n   *\n   * @param code    - A code to highlight.\n   * @param elm     - Optional. An element to highlight.\n   * @param options - Optional. Options.\n   */\n  protected getRenderer( code: string, elm?: HTMLElement, options?: Options ) {\n    options = assign( {}, this.options, options );\n\n    const language     = options.language;\n    const { name, id } = RyuseiLight.getLexer( language ).language;\n    return new Renderer( RyuseiLight.tokenize( code, language ), { name, id }, elm, options );\n  }\n\n  /**\n   * Applies the highlighter to elements that matches the selector or the provided element.\n   *\n   * @param target  - A selector or an element.\n   * @param options - Optional. Options.\n   */\n  apply( target: string | Element, options?: Options ): void {\n    const elms = isString( target ) ? document.querySelectorAll( target ) : [ target ];\n\n    for ( let i = 0; i < elms.length; i++ ) {\n      const elm = elms[ i ];\n\n      if ( isHTMLElement( elm ) ) {\n        const elmOptions = assign( {}, options, { language: attr( elm, ATTRIBUTE_LANGUAGE ) || undefined } );\n        const renderer   = this.getRenderer( text( elm ), elm, elmOptions );\n        const isPre      = elm instanceof HTMLPreElement;\n\n        if ( isPre ) {\n          addClass( elm, [ ROOT, `${ ROOT }--${ renderer.info.id }` ] );\n        }\n\n        elm.innerHTML = renderer.html( ! isPre );\n\n        renderer.event.emit( 'applied', elm );\n        this.renderers.push( renderer );\n      }\n    }\n  }\n\n  /**\n   * Returns highlighted HTML by tokenizing the provided code.\n   *\n   * @param code    - Code to highlight.\n   * @param options - Optional. Options.\n   *\n   * @return Highlighted HTML string.\n   */\n  html( code: string, options?: Options ): string {\n    assert( isString( code ), 'Invalid code.' );\n    return this.getRenderer( code, null, options ).html( true );\n  }\n\n  /**\n   * Destroys the instance.\n   */\n  destroy(): void {\n    this.renderers.forEach( renderer => {\n      renderer.destroy();\n    } );\n  }\n}\n","import { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { Renderer } from '../../core/Renderer/Renderer';\nimport { ACTIVE } from '../../constants/classes';\nimport { attr, error, isArray } from '../../utils';\n\n\n/**\n * The data attribute name for active lines.\n * The value must be an array in JSON format, such as \"[ 2, [ 5, 10 ] ]\"\n *\n * @private\n * @since 0.0.1\n */\nexport const ATTRIBUTE_ACTIVE_LINES = `data-${ PROJECT_CODE_SHORT }-active-lines`;\n\n/**\n * The component for highlighting lines.\n *\n * @since 0.0.1\n */\nexport function ActiveLines( { event, root, options }: Renderer ): void {\n  const lines = ( root && parseData( root ) ) || options.activeLines;\n\n  if ( isArray( lines ) ) {\n    const activeLines = normalize( lines );\n\n    event.on( 'gutter:row:open', ( html, classes, index ) => {\n      if ( activeLines[ index ] ) {\n        classes.push( activeLines[ index ] );\n      }\n    } );\n\n    event.on( 'line:open', ( html, classes, index ) => {\n      if ( activeLines[ index ] ) {\n        classes.push( activeLines[ index ] );\n      }\n    } );\n  }\n}\n\n/**\n * Attempts to get definition of active lines from a data attribute.\n *\n * @param elm - A root element.\n *\n * @return An array with line numbers if available, or otherwise `undefined`.\n */\nfunction parseData( elm: HTMLElement ): Array<number | [ number, number ]> | void {\n  const data = attr( elm, ATTRIBUTE_ACTIVE_LINES );\n\n  if ( data ) {\n    try {\n      return JSON.parse( data );\n    } catch ( e ) {\n      error( e.message );\n    }\n  }\n}\n\n/**\n * Normalizes the definition of lines to activate.\n *\n * @param lines - An array with line numbers.\n *\n * @return An array with normalized line numbers.\n */\nfunction normalize( lines: Array<number | [ number, number ]> ): string[] {\n  const numbers = [];\n\n  lines.forEach( range => {\n    if ( ! isArray( range ) ) {\n      range = [ range, range ];\n    }\n\n    const start = ( +range[ 0 ] || 1 ) - 1;\n    const end   = ( +range[ 1 ] || 1 ) - 1;\n\n    for ( let i = start; i <= end; i++ ) {\n      numbers[ i ] = ACTIVE;\n    }\n  } );\n\n  return numbers;\n}\n","import { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { Renderer } from '../../core/Renderer/Renderer';\nimport { assign, attr, isObject, isString } from '../../utils';\n\n\n/**\n * The data attribute name for a caption.\n *\n * @since 0.0.22\n */\nexport const ATTRIBUTE_CAPTION = `data-${ PROJECT_CODE_SHORT }-caption`;\n\n/**\n * The component for wrapping a code snipped by a figure tag and appending a figcaption.\n *\n * @since 0.0.22\n */\nexport function Caption( { event, root, options }: Renderer ) {\n  const attrCaption = root && attr( root, ATTRIBUTE_CAPTION );\n\n  if ( ! attrCaption && ! options.caption ) {\n    return;\n  }\n\n  const captionOptions = options.caption;\n  const { position, html } = assign( {}, isObject( captionOptions ) ? captionOptions : null );\n  const caption = attrCaption || html || ( isString( captionOptions ) ? captionOptions : '' );\n\n  if ( caption ) {\n    const bottom = position === 'bottom';\n\n    event.on( 'open', append => {\n      append( `<figure class=\"${ PROJECT_CODE_SHORT }__figure\">` );\n\n      if ( ! bottom ) {\n        appendCaption( append, caption );\n      }\n    } );\n\n    event.on( 'closed', append => {\n      if ( bottom ) {\n        appendCaption( append, caption, true );\n      }\n\n      append( '</figure>' );\n    } );\n  }\n}\n\n/**\n * Appends a figcaption element with a provided caption.\n *\n * @param append  - The append function.\n * @param caption - A caption.\n * @param bottom  - Optional. Set `true` for a bottom caption.\n */\nfunction appendCaption( append: ( html: string ) => void, caption: string, bottom?: boolean ): void {\n  const className = `${ PROJECT_CODE_SHORT }__figcaption`;\n\n  append( `<figcaption class=\"${ className } ${ className + ( bottom ? '--bottom' : '--top' ) }\">` );\n  append( `<span>${ caption }</span>` );\n  append( `</figcaption>` );\n}\n","import { Renderer } from '../../core/Renderer/Renderer';\nimport { LINE_BREAK } from '../../constants/characters';\nimport { ACTIVE } from '../../constants/classes';\nimport { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { addClass, append, assign, create, isObject, query, styles } from '../../utils';\n\n\n/**\n * Default options for the Copy component.\n *\n * @private\n *\n * @since 0.0.1\n */\nexport const DEFAULT_OPTIONS = {\n  html      : 'Copy',\n  activeHtml: 'Done',\n  duration  : 1000,\n  ariaLabel : 'Copy code to clipboard',\n  position  : 'topRight',\n};\n\n/**\n * The component for creating a copy button and handling click.\n *\n * @since 0.0.1\n */\nexport function Copy( { lines, event, options }: Renderer ): void {\n  if ( options.copy ) {\n    const copyOptions = assign( {}, DEFAULT_OPTIONS, isObject( options.copy ) ? options.copy : {} );\n    const buttonClass = `${ PROJECT_CODE_SHORT }__copy`;\n    const labelClass  = `${ PROJECT_CODE_SHORT }__button__label`;\n\n    options.tools = copyOptions.position;\n\n    event.on( `tools:${ copyOptions.position }`, append => {\n      append( `<button type=\"button\" class=\"rl__button ${ buttonClass }\" aria-label=\"${ copyOptions.ariaLabel }\">` );\n      append( `<span class=\"${ labelClass } ${ labelClass }--inactive\">${ copyOptions.html }</span>` );\n      append( `<span class=\"${ labelClass } ${ labelClass }--active\">${ copyOptions.activeHtml }</span>` );\n      append( `</button>` );\n    } );\n\n    event.on( 'applied', root => {\n      const button = query<HTMLButtonElement>( `.${ buttonClass }`, root );\n      const code   = lines.map( line => line.map( token => token[ 1 ] ).join( '' ) ).join( LINE_BREAK );\n\n      if ( button ) {\n        const onClick = () => { copy( code, button, copyOptions.duration ) };\n        button.addEventListener( 'click', onClick );\n\n        event.on( 'destroy', () => {\n          button.removeEventListener( 'click', onClick );\n        } );\n      }\n    } );\n  }\n}\n\n/**\n * Attempts to copy the provided code by the Clipboard API.\n *\n * @param code     - A code to copy.\n * @param button   - A button element.\n * @param duration - Duration for the button activation.\n */\nfunction copy( code: string, button: HTMLButtonElement, duration: number ): void {\n  const onSuccess = () => {\n    if ( duration ) {\n      toggleClass( button, duration );\n    }\n  };\n\n  if ( navigator.clipboard ) {\n    navigator.clipboard.writeText( code )\n      .then( onSuccess )\n      .catch( () => execCopy( code, onSuccess ) );\n  } else {\n    execCopy( code, onSuccess );\n  }\n}\n\n/**\n * Attempts to copy the provided code by the `document.execCommand()` for old browsers.\n * Note that this method is deprecated.\n *\n * @param code      - Code to copy.\n * @param onSuccess - Called after the copy is done.\n */\nfunction execCopy( code: string, onSuccess: () => void ): void {\n  const textarea = create( 'textarea' );\n  textarea.textContent = code;\n\n  styles( textarea, { position: 'absolute', left: '-99999px' } );\n  append( document.body, textarea );\n\n  textarea.focus();\n  textarea.select();\n\n  let failed;\n\n  try {\n    document.execCommand( 'copy' );\n  } catch ( e ) {\n    alert( 'Failed to copy.' );\n    failed = true;\n  }\n\n  document.body.removeChild( textarea );\n\n  if ( ! failed ) {\n    onSuccess();\n  }\n}\n\n/**\n * Toggles the active class of the button.\n *\n * @param button   - A button element.\n * @param duration - Duration for the button activation.\n */\nfunction toggleClass( button: HTMLButtonElement, duration: number ): void {\n  addClass( button, ACTIVE );\n\n  const prop = '_rlTimer';\n\n  if ( button[ prop ] ) {\n    clearTimeout( button[ prop ] );\n  }\n\n  button[ prop ] = setTimeout( () => {\n    button.classList.remove( ACTIVE );\n  }, duration );\n}\n","import { append }   from '../append/append';\nimport { addClass } from '../addClass/addClass';\n\n\n/**\n * Creates an HTML element.\n *\n * @param tag     - A tag name.\n * @param classes - Optional. Classes to add.\n * @param parent  - Optional. A parent element where the created element is appended.\n */\nexport function create<K extends keyof HTMLElementTagNameMap>(\n  tag: K,\n  classes?: string | string[],\n  parent?: HTMLElement\n): HTMLElementTagNameMap[ K ] {\n  const elm = document.createElement( tag );\n\n  if ( classes ) {\n    addClass( elm, classes );\n  }\n\n  if ( parent ) {\n    append( parent, elm );\n  }\n\n  return elm;\n}\n","import { CATEGORY_SPACE } from '../../constants/categories';\nimport { LINE_BREAK } from '../../constants/characters';\nimport { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { Renderer } from '../../core/Renderer/Renderer';\nimport { Token } from '../../types';\nimport { assign, isObject, startsWith } from '../../utils';\n\n\n/**\n * The class name for added lines.\n *\n * @private\n * @since 0.0.17\n */\nexport const CLASS_ADDED = 'is-added';\n\n/**\n * The class name for deleted lines.\n *\n * @private\n * @since 0.0.17\n */\nexport const CLASS_DELETED = 'is-deleted';\n\n/**\n * The class name for deleted lines.\n *\n * @private\n * @since 0.0.17\n */\nexport const CLASS_DIFF = `${ PROJECT_CODE_SHORT }__diff`;\n\n/**\n * Default options for the Diff component.\n *\n * @since 0.0.17\n */\nconst DEFAULT_OPTIONS = {\n  addedSymbol  : '+',\n  deletedSymbol: '-',\n};\n\n/**\n * The component for highlighting added/deleted lines.\n *\n * @since 0.0.17\n */\nexport function Diff( { event, lines, options }: Renderer ): void {\n  if ( ! options.diff ) {\n    return;\n  }\n\n  options.gutter = true;\n\n  const diffOptions = assign( {}, DEFAULT_OPTIONS, isObject( options.diff ) ? options.diff : null );\n  const added       = [];\n  const deleted     = [];\n\n  lines.forEach( ( tokens, index ) => {\n    if ( tokens.length ) {\n      const text = tokens[ 0 ][ 1 ];\n\n      let processed;\n\n      if ( startsWith( text, diffOptions.addedSymbol ) ) {\n        added.push( index );\n        processed = true;\n      } else if ( startsWith( text, diffOptions.deletedSymbol ) ) {\n        deleted.push( index );\n        processed = true;\n      }\n\n      if ( processed ) {\n        convertSymbols( diffOptions.removeSymbols, tokens );\n      }\n    }\n  } );\n\n  if ( ! added.length && ! deleted.length ) {\n    return;\n  }\n\n  event.on( 'line:open', ( append, classes, i ) => {\n    addClass( added, deleted, i, classes );\n  } );\n\n  event.on( 'gutter:row:open', ( append, classes, i ) => {\n    addClass( added, deleted, i, classes );\n  } );\n\n  event.on( 'gutter:row:opened', ( append, i ) => {\n    let content = LINE_BREAK;\n\n    if ( added.indexOf( i ) > -1 ) {\n      content = diffOptions.addedSymbol;\n    } else if ( deleted.indexOf( i ) > -1 ) {\n      content = diffOptions.deletedSymbol;\n    }\n\n    append( `<span class=\"${ CLASS_DIFF }\">${ content }</span>` );\n  }, 20 );\n\n  event.on( 'lineNumber:open', ( append, classes, i, data ) => {\n    data.skip = deleted.indexOf( i ) > -1;\n  } );\n}\n\n/**\n * Adds a status class according to the added or deleted lines.\n *\n * @param added   - An array with added line indices.\n * @param deleted - An array with deleted line indices.\n * @param index   - A line index.\n * @param classes - An array with line classes.\n */\nfunction addClass( added: number[], deleted: number[], index: number, classes: string[] ): void {\n  if ( added.indexOf( index ) > -1 ) {\n    classes.push( CLASS_ADDED );\n  } else if ( deleted.indexOf( index ) > -1 ) {\n    classes.push( CLASS_DELETED );\n  }\n}\n\n/**\n * Converts +/- symbols to spaces or removes them.\n *\n * @param remove - Whether to remove symbols or not.\n * @param tokens - Target tokens.\n */\nfunction convertSymbols( remove: boolean, tokens: Token[] ): void {\n  const [ category, text ] = tokens[ 0 ];\n\n  if ( remove ) {\n    if ( text.length === 1 ) {\n      tokens.shift();\n    } else {\n      tokens[ 0 ] = [ category, text.slice( 1 ) ];\n    }\n  } else {\n    const spaceToken: Token = [ CATEGORY_SPACE, ' ' ];\n\n    if ( text.length === 1 ) {\n      tokens[ 0 ] = spaceToken;\n    } else {\n      tokens[ 0 ] = [ category, text.slice( 1 ) ];\n      tokens.unshift( spaceToken );\n    }\n  }\n}\n","import { Renderer } from '../../core/Renderer/Renderer';\nimport { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { CODE } from '../../constants/classes';\nimport { styles, throttle, isHTMLElement, query } from '../../utils';\n\n\n/**\n * The throttle duration in milliseconds for resizing gutter rows.\n *\n * @since 0.0.1\n */\nconst THROTTLE_DURATION = 100;\n\n/**\n * The class name for a gutter element.\n *\n * @since 0.0.1\n */\nexport const GUTTER_CLASS_NAME = `${ PROJECT_CODE_SHORT }__gutter`;\n\n/**\n * The class name for row element in a gutter.\n *\n * @since 0.0.1\n */\nexport const GUTTER_ROW_CLASS_NAME = `${ GUTTER_CLASS_NAME }__row`;\n\n/**\n * The component for creating a gutter and its rows.\n * This is usually activated by other components through the `gutter` option.\n *\n * @since 0.0.1\n */\nexport function Gutter( { lines, event, root, options }: Renderer ): void {\n  // Wait for initialization of other components.\n  event.on( 'mounted', () => {\n    if ( ! options.gutter ) {\n      return;\n    }\n\n    event.on( 'open', ( append, classes ) => {\n      classes.push( 'has-gutter' );\n    } );\n\n    event.on( 'code:open', append => {\n      append( `<div class=\"${ GUTTER_CLASS_NAME }\" aria-hidden=\"true\">` );\n\n      for ( let i = 0; i < lines.length; i++ ) {\n        const classes = [ GUTTER_ROW_CLASS_NAME ];\n        event.emit( 'gutter:row:open', append, classes, i );\n\n        append( `<div class=\"${ classes.join( ' ' ) }\">` );\n        event.emit( 'gutter:row:opened', append, i );\n        append( `</div>` );\n      }\n\n      append( `</div>` );\n    } );\n\n    if ( ! root || typeof window === 'undefined' ) {\n      return;\n    }\n\n    window.addEventListener( 'resize', throttle( resize, THROTTLE_DURATION ) );\n    resize();\n\n    event.on( 'destroy', () => {\n      window.removeEventListener( 'resize', resize );\n    } );\n\n    /**\n     * Resizes rows according to line height.\n     */\n    function resize() {\n      const rows = root.getElementsByClassName( GUTTER_ROW_CLASS_NAME );\n      const code = query( `.${ CODE }`, root );\n\n      if ( rows.length && code ) {\n        for ( let i = 0; i < code.children.length; i++ ) {\n          const row  = rows[ i ];\n          const line = code.children[ i ];\n\n          if ( isHTMLElement( row ) && row.clientHeight !== line.clientHeight ) {\n            styles( row, { height: `${ line.clientHeight }px` } );\n          }\n        }\n      }\n    }\n  } );\n}\n","import { PROJECT_CODE } from '../../../constants/project';\n\n\n/**\n * Displays an error message on the console.\n *\n * @param message - An error message.\n */\nexport function error( message: string ): void {\n  console.error( `[${ PROJECT_CODE }] ${ message }` );\n}\n","import { AnyFunction } from '../../../types';\n\n\n/**\n * Returns a function that invokes the provided function at most once in the specified duration.\n *\n * @since 0.0.1\n *\n * @param callback - A function to throttle.\n * @param interval - A throttle duration in milliseconds.\n *\n * @return A throttled function.\n */\nexport function throttle( callback: AnyFunction, interval: number ): () => void {\n  let timer;\n\n  return function () {\n    if ( ! timer ) {\n      timer = setTimeout( () => {\n        callback();\n        timer = null;\n      }, interval );\n    }\n  };\n}\n","import { Renderer } from '../../core/Renderer/Renderer';\nimport { PROJECT_CODE_SHORT } from '../../constants/project';\n\n\n/**\n * The component for rendering a language name.\n *\n * @since 0.0.1\n */\nexport function LanguageName( { event, info, options }: Renderer ) {\n  const { name } = info;\n\n  if ( options.languageName && name ) {\n    const position = options.languageName === 'topLeft' ? 'topLeft' : 'topRight';\n    options.overlay = options.overlay || {};\n    options.overlay[ position ] = true;\n\n    event.on( `overlay:${ position }`, append => {\n      append( `<span class=\"${ PROJECT_CODE_SHORT }__name\">${ info.name }</span>` );\n    } );\n  }\n}\n","import { LINE_BREAK } from '../../constants/characters';\nimport { Renderer } from '../../core/Renderer/Renderer';\nimport { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { attr } from '../../utils';\n\n\n/**\n * The data attribute name for line numbers.\n * This accepts boolean or number as a value.\n *\n * @private\n * @since 0.0.1\n */\nexport const ATTRIBUTE_LINE_NUMBERS = `data-${ PROJECT_CODE_SHORT }-line-numbers`;\n\n/**\n * The class name for each line number element.\n *\n * @private\n * @since 0.0.23\n */\nexport const LINE_NUMBER_CLASS_NAME = `${ PROJECT_CODE_SHORT }__line-number`;\n\n/**\n * The component for displaying line numbers in a gutter.\n *\n * @since 0.0.1\n */\nexport function LineNumbers( { root, event, options }: Renderer ): void {\n  const data   = root ? attr( root, ATTRIBUTE_LINE_NUMBERS ) : '';\n  const number = data === '' ? +options.lineNumbers : +data;\n\n  if ( number || number === 0 ) {\n    options.gutter = true;\n    let offset = Math.floor( number ) - 1;\n\n    event.on( 'gutter:row:opened', ( append, i ) => {\n      const classes = [ LINE_NUMBER_CLASS_NAME ];\n      const data    = { skip: false, content: i + 1 + offset };\n\n      event.emit( 'lineNumber:open', append, classes, i, data );\n\n      if ( data.skip ) {\n        data.content = LINE_BREAK;\n        offset--;\n      }\n\n      append( `<span class=\"${ classes.join( ' ' ) }\">${ data.content }</span>` );\n    } );\n  }\n}\n","import { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { Renderer } from '../../core/Renderer/Renderer';\nimport { EventBus } from '../../event/EventBus';\n\n\n/**\n * The component for rendering overlay and tools elements.\n *\n * @since 0.0.1\n */\nexport function Overlay( { event, options }: Renderer ) {\n  event.on( 'mounted', () => {\n    const { overlay = {} } = options;\n    const { tools } = options;\n    let { topRight, topLeft } = overlay;\n\n    topRight = topRight || tools === 'topRight';\n    topLeft  = topLeft || tools === 'topLeft';\n\n    [ topRight, topLeft ].forEach( ( active, index ) => {\n      if ( active ) {\n        if ( tools ) {\n          appendTools( event, index === 1 );\n        }\n\n        appendOverlay( event, index === 1 );\n      }\n    } );\n\n    if ( topRight || topLeft ) {\n      event.on( 'open', ( append, classes ) => {\n        classes.push( 'has-top-overlay' );\n      } );\n    }\n  } );\n}\n\n/**\n * Appends HTML for the overlay.\n *\n * @private\n *\n * @param event - The EventBus object.\n * @param left  - Optional. Set `true` for the left overlay.\n */\nfunction appendOverlay( event: EventBus, left?: boolean ) {\n  const className = `${ PROJECT_CODE_SHORT }__overlay`;\n\n  event.on( 'close', append => {\n    append( `<div class=\"${ className } ${ className }--top-${ left ? 'left' : 'right' }\">` );\n    event.emit( `overlay:top${ left ? 'Left' : 'Right' }`, append );\n    append( `</div>` );\n  } );\n}\n\n/**\n * Appends HTML for tools.\n *\n * @private\n *\n * @param event - The EventBus object.\n * @param left  - Optional. Set `true` for the left tools.\n */\nfunction appendTools( event: EventBus, left?: boolean ): void {\n  const position = left ? 'Left' : 'Right';\n\n  event.on( `overlay:top${ position }`, append => {\n    append( `<span class=\"${ PROJECT_CODE_SHORT }__tools\">` );\n    event.emit( `tools:top${ position }`, append );\n    append( `</span>` );\n  } );\n}\n","import { RyuseiLight } from '../core/RyuseiLight/RyuseiLight';\nimport * as languages  from '../languages';\nimport * as components from '../components';\nimport { forOwn } from '../utils';\n\nforOwn( languages, language => {\n  RyuseiLight.register( language() );\n} );\n\nRyuseiLight.compose( components );\n\nexport { RyuseiLight as default } from '../core/RyuseiLight/RyuseiLight';\n"],"names":["LINE_BREAK","CATEGORY_KEYWORD","CATEGORY_COMMENT","CATEGORY_TAG","CATEGORY_SELECTOR","CATEGORY_ATTRIBUTE","CATEGORY_PROPERTY","CATEGORY_VALUE","CATEGORY_PROLOG","CATEGORY_STRING","CATEGORY_NUMBER","CATEGORY_BOOLEAN","CATEGORY_FUNCTION","CATEGORY_CLASS","CATEGORY_OPERATOR","CATEGORY_BRACKET","CATEGORY_DELIMITER","CATEGORY_SPACE","CATEGORY_TEXT","isObject","subject","isArray","Array","isString","isUndefined","isHTMLElement","HTMLElement","toArray","value","addClass","elm","classes","forEach","name","classList","add","append","parent","children","i","length","appendChild","forOwn","object","iteratee","keys","Object","assign","sources","source","key","attr","attrs","getAttribute","setAttribute","String","query","selector","document","querySelector","styles","style","tag","join","text","node","textContent","assert","condition","message","Error","PROJECT_CODE","before","map","ref","entries","index","find","splice","push","startsWith","string","char","charAt","isStickySupported","sticky","Lexer","language","init","grammar","tokenizers","_this","merge","use","this","bind","merged","tokenizer","category","regexp","slice","flags","toString","match","replace","replacement","RegExp","parse","state","position","depth","main","aborted","action","lastIndex","exec","handle","token","start","from","indexOf","line","lines","empty","code","undefined","info","id","head","tail","split","distance","limit","console","log","lang","input","tokenize","ROOT","BODY","PROJECT_CODE_SHORT","CODE","TOKEN","ACTIVE","EventBus","on","event","callback","priority","handlers","sort","handler1","handler2","emit","args","handler","destroy","Components","Renderer","root","options","compose","components","Component","tokens","trim","pop","_this2","renderLines","tagName","span","j","categories","className","modifiers","sub","concat","html","pre","closeTag","fragment","containerClasses","bodyClasses","wrap","REGEXP_NUMBER","REGEXP_BOOLEAN","REGEXP_BRACKET","REGEXP_SPACE","REGEXP_QUOTE","REGEXP_DOUBLE_QUOTE","REGEXP_MULTILINE_COMMENT","REGEXP_SLASH_COMMENT","REGEXP_GENERAL_KEYWORDS","css","findBlock","findSingleAtrule","findAtrule","findSelector","common","block","inner","atrule","paren","url","props","javascript","alias","func","backtick","expression","script","cdata","unshift","tagContent","jsx","base","findPairedTag","findSelfClosedTag","findBracket","pairedTag","selfClosedTag","openTag","none","xml","typescript","functions","filter","findInterp","singleQuote","doubleQuote","interp","lexers","RyuseiLight","register","languages","getLexer","has","getRenderer","apply","target","elms","querySelectorAll","elmOptions","renderer","isPre","HTMLPreElement","innerHTML","renderers","ATTRIBUTE_ACTIVE_LINES","appendCaption","caption","bottom","DEFAULT_OPTIONS","activeHtml","duration","ariaLabel","execCopy","onSuccess","failed","textarea","createElement","create","left","body","focus","select","execCommand","e","alert","removeChild","addedSymbol","deletedSymbol","added","deleted","GUTTER_ROW_CLASS_NAME","GUTTER_CLASS_NAME","data","JSON","error","parseData","activeLines","numbers","range","end","normalize","attrCaption","captionOptions","copy","copyOptions","labelClass","tools","button","onClick","prop","clearTimeout","setTimeout","remove","toggleClass","navigator","clipboard","writeText","then","catch","addEventListener","removeEventListener","diff","gutter","diffOptions","processed","shift","spaceToken","convertSymbols","removeSymbols","content","skip","interval","timer","window","resize","rows","getElementsByClassName","row","clientHeight","height","languageName","overlay","number","lineNumbers","offset","Math","floor","topRight","topLeft","active","appendTools","appendOverlay"],"mappings":"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"}