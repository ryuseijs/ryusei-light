{"version":3,"file":"ryuseilight-complete.min.js","sources":["../../src/js/constants/categories.ts","../../src/js/utils/type/type.ts","../../src/js/utils/array/toArray/toArray.ts","../../src/js/utils/dom/addClass/addClass.ts","../../src/js/utils/object/forOwn/forOwn.ts","../../src/js/utils/object/assign/assign.ts","../../src/js/utils/dom/attr/attr.ts","../../src/js/utils/dom/query/query.ts","../../src/js/utils/dom/styles/styles.ts","../../src/js/utils/dom/text/text.ts","../../src/js/utils/error/assert/assert.ts","../../src/js/constants/project.ts","../../src/js/utils/map/before/before.ts","../../src/js/utils/map/find/find.ts","../../src/js/utils/string/startsWith/startsWith.ts","../../src/js/core/Lexer/Lexer.ts","../../src/js/utils/regexp/getFlags/getFlags.ts","../../src/js/constants/characters.ts","../../src/js/event/EventBus.ts","../../src/js/constants/classes.ts","../../src/js/core/Renderer/Renderer.ts","../../src/js/utils/string/escapeHtml/escapeHtml.ts","../../src/js/constants/regexp.ts","../../src/js/languages/common/common.ts","../../src/js/languages/css/css.ts","../../src/js/languages/javascript/javascript.ts","../../src/js/languages/html/html.ts","../../src/js/languages/none/none.ts","../../src/js/languages/xml/xml.ts","../../src/js/languages/json/json.ts","../../src/js/languages/jsx/jsx.ts","../../src/js/languages/scss/scss.ts","../../src/js/languages/svg/svg.ts","../../src/js/languages/typescript/typescript.ts","../../src/js/languages/vue/vue.ts","../../src/js/core/RyuseiLight/RyuseiLight.ts","../../src/js/components/ActiveLines/ActiveLines.ts","../../src/js/utils/error/error/error.ts","../../src/js/components/Gutter/Gutter.ts","../../src/js/utils/function/throttle/throttle.ts","../../src/js/components/LanguageName/LanguageName.ts","../../src/js/components/LineNumbers/LineNumbers.ts","../../src/js/components/Overlay/Overlay.ts","../../src/js/components/Title/Title.ts","../../src/js/build/complete.ts"],"sourcesContent":["export const CATEGORY_KEYWORD = 'keyword';\n\nexport const CATEGORY_COMMENT = 'comment';\n\nexport const CATEGORY_TAG = 'tag';\n\nexport const CATEGORY_SELECTOR = 'selector';\n\nexport const CATEGORY_ATTRIBUTE = 'attr';\n\nexport const CATEGORY_PROPERTY = 'prop';\n\nexport const CATEGORY_VALUE = 'value';\n\nexport const CATEGORY_VARIABLE = 'variable';\n\nexport const CATEGORY_ENTITY = 'entity';\n\nexport const CATEGORY_PROLOG = 'prolog';\n\nexport const CATEGORY_IDENTIFIER = 'identifier';\n\nexport const CATEGORY_STRING = 'string';\n\nexport const CATEGORY_NUMBER = 'number';\n\nexport const CATEGORY_BOOLEAN = 'boolean';\n\nexport const CATEGORY_FUNCTION = 'function';\n\nexport const CATEGORY_CLASS = 'class';\n\nexport const CATEGORY_DECORATOR = 'decorator';\n\nexport const CATEGORY_REGEXP = 'regexp';\n\nexport const CATEGORY_OPERATOR = 'operator';\n\nexport const CATEGORY_BRACKET = 'bracket';\n\nexport const CATEGORY_SYMBOL = 'symbol';\n\nexport const CATEGORY_SPACE = 'space';\n\nexport const CATEGORY_TEXT = 'text';\n","/**\n * Checks if the given subject is an object or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is an object, or otherwise `false`.\n */\nexport function isObject<T extends object>( subject: any ): subject is T {\n  return subject !== null && typeof subject === 'object';\n}\n\n/**\n * Checks if the given subject is an array or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is an array, or otherwise `false`.\n */\nexport function isArray<T>( subject: any ): subject is T[] {\n  return Array.isArray( subject );\n}\n\n/**\n * Checks if the given subject is a function or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is a function, or otherwise `false`.\n */\nexport function isFunction( subject: any ): subject is ( ...args: any[] ) => any {\n  return typeof subject === 'function';\n}\n\n/**\n * Checks if the given subject is a string or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is a string, or otherwise `false`.\n */\nexport function isString( subject: any ): subject is string {\n  return typeof subject === 'string';\n}\n\n/**\n * Checks if the given subject is `undefined` or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is `undefined`, or otherwise `false`.\n */\nexport function isUndefined( subject: any ): subject is undefined {\n  return typeof subject === 'undefined';\n}\n\n/**\n * Checks if the given subject is a HTMLElement instance or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is a HTMLElement instance, or otherwise `false`.\n */\nexport function isHTMLElement( subject: any ): subject is HTMLElement {\n  return subject instanceof HTMLElement;\n}\n","import { isArray } from '../../type/type';\n\n\n/**\n * Push the provided value to an array only if the value is not an array.\n *\n * @param value - A value to push.\n *\n * @return An array containing the value, or the value itself if it is already an array.\n */\nexport function toArray<T>( value: T | T[] ): T[] {\n  return isArray<T>( value ) ? value : [ value ];\n}\n","import { toArray } from '../../array';\n\n\n/**\n * Adds classes to the element.\n *\n * @param elm     - An element to add classes to.\n * @param classes - Classes to add.\n */\nexport function addClass( elm: HTMLElement, classes: string | string[] ): void {\n  toArray( classes ).forEach( name => {\n    if ( name ) {\n      elm.classList.add( name );\n    }\n  } );\n}\n","/**\n * Iterates over the provided object by own enumerable keys with calling the iteratee function.\n *\n * @param object   - An object to iterate over.\n * @param iteratee - An iteratee function that takes the value and key as arguments.\n *\n * @return A provided object itself.\n */\nexport function forOwn<T extends object>( object: T, iteratee: ( value: T[ keyof T ], key: string ) => void ) {\n  const keys = Object.keys( object );\n\n  for ( let i = 0; i < keys.length; i++ ) {\n    iteratee( object[ keys[ i ] ], keys[ i ] );\n  }\n}\n","import { isUndefined } from '../../type/type';\nimport { forOwn } from '../forOwn/forOwn';\n\n\n/**\n * Assign U to T.\n *\n * @typeParam T - An object to assign to.\n * @typeParam U - An object to assign.\n *\n * @return An assigned object type.\n */\nexport type Assign<T, U> = Omit<T, keyof U> & U;\n\nexport function assign<T extends object>( object: T ): T;\n\n// There is a way to type arguments recursively, but these fixed definitions are enough for this project.\nexport function assign<T extends object, U extends object>( object: T, source: U ): Assign<T, U>;\n\nexport function assign<T extends object, U1 extends object, U2 extends object>(\n  object: T, source1: U1, source2: U2\n): Assign<Assign<T, U1>, U2>;\n\nexport function assign<T extends object, U1 extends object, U2 extends object, U3 extends object>(\n  object: T, source1: U1, source2: U2, source3: U3\n): Assign<Assign<Assign<T, U1>, U2>, U3>;\n\n/**\n * Assigns all own enumerable properties of all source objects to the provided object.\n * `undefined` in source objects will be skipped.\n *\n * @param object  - An object to assign properties to.\n * @param sources - Objects to assign properties from.\n *\n * @return An object assigned properties of the sources to.\n */\nexport function assign<T extends object, U extends object>( object: T, ...sources: U[] ): any {\n  sources.forEach( source => {\n    forOwn( source, ( value, key ) => {\n      if ( ! isUndefined( source[ key ] ) ) {\n        object[ key ] = source[ key ];\n      }\n    } );\n  } );\n\n  return object;\n}\n","import { forOwn } from '../../object';\nimport { isObject, isString } from '../../type/type';\n\n\nexport function attr( elm: Element, attrs: string ): string;\nexport function attr( elm: Element, attrs: Record<string, string | number | boolean> ): void;\n\n/**\n * Sets new attributes to the passed element if the `attrs` is an object literal,\n * or gets an attribute value from it if the `attrs` is a string.\n *\n * @param elm   - An element to set or get an attribute.\n * @param attrs - An attribute name as a string or new attributes as an object literal.\n */\nexport function attr( elm: Element, attrs: string | Record<string, string | number | boolean> ): string | void {\n  if ( isString( attrs ) ) {\n    return elm.getAttribute( attrs ) || '';\n  }\n\n  if ( isObject( attrs ) ) {\n    forOwn( attrs, ( value, key ) => {\n      elm.setAttribute( key, String( value ) );\n    } );\n  }\n}\n","/**\n * Returns an element that matches the provided selector.\n *\n * @param selector - A selector.\n * @param parent   - Optional. A parent element to start searching elements from.\n *\n * @return A found element or `null`.\n */\nexport function query<E extends Element = HTMLElement>(\n  selector: string,\n  parent: HTMLElement | Document = document\n): E | null {\n  return parent.querySelector<E>( selector );\n}\n","import { forOwn } from '../../object';\n\n\n/**\n * Applies inline styles to the provided element by an object literal.\n *\n * @param elm    - An element to apply styles to.\n * @param styles - An object literal with styles.\n */\nexport function styles( elm: HTMLElement, styles: Record<string, string | number> ): void {\n  forOwn( styles, ( value, key ) => {\n    elm.style[ key ] = String( value );\n  } );\n}\n","import { isUndefined } from '../../type/type';\n\n\nexport function text( node: Node ): string;\nexport function text( node: Node, text: string ): void;\n\n/**\n * Sets or gets a text content of the provided node.\n *\n * @param node - A node to get or set a text.\n * @param text - Optional. A text to set.\n */\nexport function text( node: Node, text?: string ): string | void {\n  if ( isUndefined( text ) ) {\n    return node.textContent;\n  }\n\n  node.textContent = text;\n}\n","/**\n * Throws an error if the provided condition is falsy.\n *\n * @param condition - If falsy, an error is thrown.\n * @param message   - Optional. A message for the error.\n */\nexport function assert( condition: any, message = '' ): void {\n  if ( ! condition ) {\n    throw new Error( message );\n  }\n}\n","/**\n * The project code name.\n *\n * @since 0.0.1\n */\nexport const PROJECT_CODE = 'ryuseilight';\n\n/**\n * The abbreviated project code.\n *\n * @since 0.0.1\n */\nexport const PROJECT_CODE_SHORT = 'rl';\n","import { MapEntry } from '../types';\nimport { find } from '../find/find';\n\n\n/**\n * Insert entries before the reference entry specified by the `ref`.\n * If the reference is not found, a new entry is created.\n *\n * @param map     - A map to insert values to.\n * @param ref     - A reference key.\n * @param entries - entries to insert.\n */\nexport function before<T extends any>( map: MapEntry<T>[], ref: string, entries: MapEntry<T>[] ): void {\n  const index = find( map, ref );\n\n  if ( index > -1 ) {\n    map.splice( index, 0, ...entries );\n  } else {\n    map.push( ...entries );\n  }\n}\n","import { MapEntry } from '../types';\n\n\n/**\n * Finds the provided key from a map and returns its index.\n *\n * @param map - A map to search in.\n * @param key - A key to search for.\n *\n * @return An index if found, or `-1` otherwise.\n */\nexport function find<T extends any>( map: MapEntry<T>[], key: string ): number {\n  for ( let i = 0; i < map.length; i++ ) {\n    if ( map[ i ][ 0 ] === key ) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n","/**\n * Checks if the string starts with the `char` or not.\n *\n * @param string - A string to check.\n * @param char   - A character.\n *\n * @return `true` if the string starts with the `char`, or otherwise `false`.\n */\nexport function startsWith( string: string, char: string ): boolean {\n  return string.charAt( 0 ) === char;\n}\n","import { Language, Token, Tokenizer } from '../../types';\nimport { LINE_BREAK } from '../../constants/characters';\nimport { CATEGORY_TEXT } from '../../constants/categories';\nimport { assert, forOwn, isUndefined, startsWith, getFlags } from '../../utils';\n\n\n/**\n * Checks if the RegExp supports the sticky flag or not.\n */\nconst isStickySupported = ! isUndefined( /x/.sticky );\n\n/**\n * The class for creating a simple lexer by a Language object.\n *\n * @since 0.0.1\n */\nexport class Lexer {\n  /**\n   * Holds the Language object.\n   */\n  readonly language: Language;\n\n  /**\n   * Stores lines.\n   */\n  protected lines: Token[][];\n\n  /**\n   * Indicates the current line index.\n   */\n  protected index: number;\n\n  /**\n   * The Lexer constructor.\n   *\n   * @param language - A Language object.\n   */\n  constructor( language: Language ) {\n    this.language = language;\n    this.init( language );\n  }\n\n  /**\n   * Initializes the language object.\n   *\n   * @param language - A Language object to initialize.\n   */\n  protected init( language: Language ): void {\n    forOwn( language.grammar, ( tokenizers, key ) => {\n      language.grammar[ key ] = this.merge( language, tokenizers );\n    } );\n\n    language.use = language.use || {};\n    forOwn( language.use, this.init.bind( this ) );\n  }\n\n  /**\n   * Includes tokenizers required by `#` annotation and flatten them.\n   *\n   * @param language   - A language object.\n   * @param tokenizers - Tokenizers.\n   *\n   * @return Merged tokenizers.\n   */\n  protected merge( language: Language, tokenizers: Tokenizer[] ): Tokenizer[] {\n    return tokenizers.reduce( ( merged, tokenizer ) => {\n      const [ category, regexp ] = tokenizer;\n\n      if ( startsWith( category, '#' ) && ! regexp ) {\n        const include = language.grammar[ category.slice( 1 ) ];\n        assert( include );\n        merged.push( ...this.merge( language, include ) );\n      } else {\n        const flags = getFlags( regexp ).replace( /[gy]/g, '' );\n\n        if ( isStickySupported ) {\n          tokenizer[ 1 ] = new RegExp( regexp.source, 'y' + flags );\n        } else {\n          tokenizer[ 1 ] = new RegExp( regexp.source + '|()', 'g' + flags );\n        }\n\n        merged.push( tokenizer );\n      }\n\n      return merged;\n    }, [] );\n  }\n\n  /**\n   * Tokenizes the text by the provided language and tokenizers.\n   *\n   * @param text       - A text to tokenize.\n   * @param language   - A Grammar object.\n   * @param tokenizers - An array with tokenizers.\n   *\n   * @return An index of the text where the handling ends.\n   */\n  protected tokenizeBy( text: string, language: Language, tokenizers: Tokenizer[] ): number {\n    let index    = 0;\n    let position = 0;\n\n    main:\n    while ( index < text.length ) {\n      for ( let i = 0; i < tokenizers.length; i++ ) {\n        const tokenizer = tokenizers[ i ];\n        const regexp    = tokenizer[ 1 ];\n        const command   = tokenizer[ 2 ];\n\n        regexp.lastIndex = index;\n\n        const match = regexp.exec( text );\n\n        if ( ! match || ! match[ 0 ] ) {\n          continue;\n        }\n\n        if ( position < index ) {\n          this.push( [ CATEGORY_TEXT, text.slice( position, index ) ] );\n        }\n\n        if ( command === '@back' ) {\n          position = index;\n          break main;\n        }\n\n        const offset = this.handle( match, language, tokenizers[ i ] );\n\n        index += offset || 1;\n        position = index;\n\n        if ( command === '@break' ) {\n          break main;\n        }\n\n        continue main;\n      }\n\n      index++;\n    }\n\n    if ( position < index ) {\n      this.push( [ CATEGORY_TEXT, text.slice( position ) ] );\n    }\n\n    return index;\n  }\n\n  /**\n   * Pushes the provided token to the lines array.\n   *\n   * @param token - A token to push.\n   */\n  protected push( token: Token ): void {\n    const [ category ] = token;\n\n    let index;\n    let from = 0;\n    let text = token[ 1 ];\n\n    while ( ( index = text.indexOf( LINE_BREAK, from ) ) > -1 ) {\n      if ( from < index ) {\n        this.lines[ this.index ].push( [ category, text.slice( from, index ) ] );\n      }\n\n      from = index + 1;\n      this.lines[ ++this.index ] = [];\n    }\n\n    text = text.slice( from );\n\n    if ( text ) {\n      this.lines[ this.index ].push( [ category, text ] );\n    }\n  }\n\n  /**\n   * Handles the matched text.\n   *\n   * @param match     - A matched result.\n   * @param language  - A Language object.\n   * @param tokenizer - A tokenizer that has been matched with the text.\n   *\n   * @return An index of the text where the handling ends.\n   */\n  protected handle( match: RegExpExecArray, language: Language, tokenizer: Tokenizer ): number {\n    const [ category ] = tokenizer;\n    let offset = 0;\n\n    if ( category ) {\n      const [ text ] = match;\n\n      if ( startsWith( category, '@' ) ) {\n        const lang = language.use[ category.slice( 1 ) ];\n        assert( lang );\n\n        return this.tokenizeBy( text, lang, lang.grammar.main );\n      }\n\n      if ( startsWith( category, '#' ) ) {\n        const tokenizers = language.grammar[ category.slice( 1 ) ];\n        assert( tokenizers );\n\n        const value = tokenizer[ 2 ] === '@rest' ? match.input.slice( match.index ) : text;\n        return this.tokenizeBy( value, language, tokenizers );\n      }\n\n      offset = text.length;\n      this.push( [ category, text ] );\n    }\n\n    return offset;\n  }\n\n  /**\n   * Tokenizes the text by the current language.\n   *\n   * @param text  - A text to tokenize.\n   *\n   * @return An array with tokens.\n   */\n  tokenize( text: string ): Token[][] {\n    this.lines = [ [] ];\n    this.index = 0;\n\n    this.tokenizeBy( text, this.language, this.language.grammar.main );\n\n    return this.lines;\n  }\n}\n","/**\n * Returns flags of the provided regexp object.\n * IE doesn't support RegExp#flags.\n *\n * @param regexp - A RegExp object.\n *\n * @return Flags as a string.\n */\nexport function getFlags( regexp: RegExp ): string {\n  return regexp.toString().match( /[gimsy]*$/ )[ 0 ];\n}\n","/**\n * The line break character.\n *\n * @private\n * @since 0.0.1\n */\nexport const LINE_BREAK = '\\n';\n","import { AnyFunction } from '../types';\n\n\n/**\n * The class for providing the very simple event bus.\n *\n * @private\n * @since 0.0.1\n */\nexport class EventBus {\n  /**\n   * Holds handlers.\n   */\n  protected handlers = {};\n\n  /**\n   * Attaches a handler.\n   *\n   * @param event    - An event name.\n   * @param callback - A callback function to register.\n   */\n  on( event: string, callback: AnyFunction ): void {\n    const handlers = ( this.handlers[ event ] = this.handlers[ event ] || [] );\n    handlers.push( { callback } );\n  }\n\n  /**\n   * Emits an event.\n   *\n   * @param event - An event name.\n   * @param args  - Optional. Any number of arguments to pass to callbacks.\n   */\n  emit( event, ...args ): void {\n    ( this.handlers[ event ] || [] ).forEach( handler => {\n      handler.callback( ...args );\n    } );\n  }\n\n  /**\n   * Destroys the event bus.\n   */\n  destroy(): void {\n    this.handlers = {};\n  }\n}\n","import { PROJECT_CODE, PROJECT_CODE_SHORT } from './project';\n\n\n/**\n * The collection of class names.\n *\n * @since 0.0.1\n */\nexport const CLASSES = {\n  root     : PROJECT_CODE,\n  container: `${ PROJECT_CODE_SHORT }__container`,\n  body     : `${ PROJECT_CODE_SHORT }__body`,\n  code     : `${ PROJECT_CODE_SHORT }__code`,\n  line     : `${ PROJECT_CODE_SHORT }__line`,\n  token    : `${ PROJECT_CODE_SHORT }__token`,\n  active   : 'is-active',\n};\n","import { Options, LanguageInfo, Token, Component } from '../../types';\nimport { EventBus } from '../../event/EventBus';\nimport { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { CLASSES } from '../../constants/classes';\nimport { forOwn, escapeHtml } from '../../utils';\n\n\n/**\n * Stores all Component functions.\n */\nconst Components: Record<string, Component> = {};\n\n/**\n * The class for highlighting code via provided tokens.\n *\n * @since 0.0.1\n */\nexport class Renderer {\n  /**\n   * Adds components.\n   *\n   * @param components - An object literal with Component functions.\n   */\n  static compose( components: Record<string, Component> ): void {\n    forOwn( components, ( Component, name ) => {\n      if ( ! Components[ name ] ) {\n        Components[ name ] = Component;\n      }\n    } );\n  }\n\n  /**\n   * Holds lines with tokens.\n   */\n  readonly lines = [];\n\n  /**\n   * Holds the language info.\n   */\n  readonly info: LanguageInfo;\n\n  /**\n   * Holds the root element if provided.\n   */\n  readonly root: HTMLElement | undefined;\n\n  /**\n   * Holds options.\n   */\n  readonly options: Options;\n\n  /**\n   * Holds the EventBus instance.\n   */\n  readonly event: EventBus = new EventBus();\n\n  /**\n   * The Renderer constructor.\n   *\n   * @param lines   - Lines with tokens to render.\n   * @param info    - The language info object.\n   * @param root    - Optional. A root element to highlight.\n   * @param options - Options.\n   */\n  constructor( lines: Token[][], info: LanguageInfo, root?: HTMLElement, options: Options = {} ) {\n    this.lines   = lines;\n    this.info    = info;\n    this.root    = root;\n    this.options = options;\n\n    this.init();\n  }\n\n  /**\n   * Initializes the instance.\n   */\n  protected init(): void {\n    const { lines } = this;\n\n    if ( lines.length ) {\n      const tokens = lines[ lines.length - 1 ];\n\n      if ( tokens.length === 1 && ! tokens[ 0 ][ 1 ].trim() ) {\n        // Removes the last empty line.\n        lines.pop();\n      }\n    }\n\n    forOwn( Components, Component => { Component( this ) } );\n    this.event.emit( 'mounted', this );\n  }\n\n  /**\n   * Renders lines as HTML.\n   *\n   * @param append - A function to add fragments to the HTML string.\n   *\n   * @return A rendered HTML string.\n   */\n  protected renderLines( append: ( fragment: string ) => void ): void {\n    const event = this.event;\n    const tag   = this.options.span ? 'span' : 'code';\n\n    for ( let i = 0; i < this.lines.length; i++ ) {\n      const tokens  = this.lines[ i ];\n      const classes = [ CLASSES.line ];\n\n      event.emit( 'line:open', append, classes, i );\n      append( `<div class=\"${ classes.join( ' ' ) }\">` );\n\n      for ( let j = 0; j < tokens.length; j++ ) {\n        const token   = tokens[ j ];\n        const classes = [ `${ CLASSES.token } ${ PROJECT_CODE_SHORT }__${ token[ 0 ] }` ];\n\n        event.emit( 'token', token, classes );\n\n        append( `<${ tag } class=\"${ classes.join( ' ' ) }\">${ escapeHtml( token[ 1 ] ) }</${ tag }>` );\n      }\n\n      append( `</div>` );\n      event.emit( 'line:closed', append, i );\n    }\n  }\n\n  /**\n   * Returns all lines and wrapper elements.\n   *\n   * @param pre - Whether to wrap elements by `pre` or not.\n   *\n   * @return A HTML string.\n   */\n  html( pre = true ): string {\n    const event = this.event;\n    let html  = '';\n\n    const append = ( fragment: string ) => { html += fragment };\n\n    if ( pre ) {\n      html += `<pre class=\"${ CLASSES.root } ${ CLASSES.root }--${ this.info.id }\">`;\n    }\n\n    const containerClasses = [ CLASSES.container ];\n    event.emit( 'open', append, containerClasses );\n\n    html += `<div class=\"${ containerClasses.join( ' ' ) }\">`;\n    event.emit( 'opened', append );\n\n    const bodyClasses = [ `${ CLASSES.body }${ this.options.wrap ? ` ${ CLASSES.body }--wrap` : '' }` ];\n    event.emit( 'body:open', append, bodyClasses );\n\n    html += `<div class=\"${ bodyClasses.join( ' ' ) }\">`;\n    event.emit( 'body:opened', append );\n\n    html += `<div class=\"${ CLASSES.code }\">`;\n    this.renderLines( append );\n    html += `</div>`; // code\n\n    event.emit( 'body:close', append );\n    html += `</div>`; // body\n\n    event.emit( 'close', append );\n    html += `</div>`; // container\n\n    event.emit( 'closed', append );\n\n    if ( pre ) {\n      html += `</pre>`;\n    }\n\n    return html;\n  }\n\n  /**\n   * Destroys the instance.\n   */\n  destroy(): void {\n    this.event.emit( 'destroy' );\n    this.event.destroy();\n  }\n}\n","/**\n * Converts essential HTML special characters to HTML entities.\n *\n * @param string - A string to escape.\n *\n * @return An escaped string.\n */\nexport function escapeHtml( string: string ): string {\n  return string.replace( /&/g, '&amp;' ).replace( /</g, '&lt;' );\n}\n","export const REGEXP_FUNCTION = /\\b\\w+(?= *\\()/;\n\nexport const REGEXP_FLOAT = /\\d+\\.?\\d*|\\d*\\.?\\d+/;\n\nexport const REGEXP_NUMBER = /[+-]?(\\d+\\.?\\d*|\\d*\\.?\\d+)([eE][+-]?\\d+)?/;\n\nexport const REGEXP_BOOLEAN = /\\b(?:true|false)\\b/;\n\nexport const REGEXP_BRACKET = /[[\\]{}()]/;\n\nexport const REGEXP_SPACE = /[ \\t]+/;\n\nexport const REGEXP_QUOTE = /'(?:\\\\'|.)*?'/;\n\nexport const REGEXP_DOUBLE_QUOTE = /\"(?:\\\\\"|.)*?\"/;\n\nexport const REGEXP_MULTILINE_COMMENT = /\\/\\*[\\s\\S]*?\\*\\//;\n\nexport const REGEXP_SLASH_COMMENT = /\\/\\/.*/;\n","import { Language } from '../../types';\nimport {\n  CATEGORY_BOOLEAN, CATEGORY_BRACKET, CATEGORY_CLASS, CATEGORY_COMMENT, CATEGORY_FUNCTION,\n  CATEGORY_IDENTIFIER, CATEGORY_KEYWORD, CATEGORY_NUMBER, CATEGORY_OPERATOR, CATEGORY_REGEXP,\n  CATEGORY_SPACE, CATEGORY_STRING, CATEGORY_SYMBOL,\n} from '../../constants/categories';\nimport {\n  REGEXP_BOOLEAN, REGEXP_BRACKET, REGEXP_DOUBLE_QUOTE, REGEXP_FUNCTION, REGEXP_MULTILINE_COMMENT, REGEXP_NUMBER,\n  REGEXP_QUOTE, REGEXP_SLASH_COMMENT, REGEXP_SPACE,\n} from '../../constants/regexp';\n\n\n/**\n * Returns a common language definition.\n *\n * @return A Language object.\n */\nexport function common(): Language {\n  return {\n    id  : 'common',\n    name: '',\n\n    grammar: {\n      main: [\n        [ CATEGORY_STRING, REGEXP_QUOTE ],\n        [ CATEGORY_STRING, REGEXP_DOUBLE_QUOTE ],\n        [ CATEGORY_COMMENT, REGEXP_MULTILINE_COMMENT ],\n        [ CATEGORY_COMMENT, REGEXP_SLASH_COMMENT ],\n        [ CATEGORY_REGEXP, /\\/(\\\\\\/|[^\\n])+?\\/[a-z]*/ ],\n        [ CATEGORY_KEYWORD, /\\b(?:break|catch|class|continue|do|else|extends|finally|for|function|if|implements|in|instanceof|interface|new|null|return|throw|trait|try|while)\\b/ ],\n        [ CATEGORY_CLASS, /\\b[A-Z][\\w$]*\\b/ ], //todo\n        [ CATEGORY_FUNCTION, REGEXP_FUNCTION ],\n        [ CATEGORY_BOOLEAN, REGEXP_BOOLEAN ],\n        [ CATEGORY_IDENTIFIER, /\\b[a-z_$][\\w$]*\\b/ ],\n        [ CATEGORY_NUMBER, REGEXP_NUMBER ],\n        [ CATEGORY_OPERATOR, /\\+[+=]?|-[-=]?|\\*\\*?=?|\\/=?|%=?|&&?=?|\\|\\|?=?|\\?\\??=?|<<?=?|>>?=?|[!=]=?=?|[~:^]/ ],\n        [ CATEGORY_BRACKET, REGEXP_BRACKET ],\n        [ CATEGORY_SYMBOL, /[;.,@]+/ ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n    },\n  };\n}\n","import { Language } from '../../types';\nimport {\n  CATEGORY_BRACKET, CATEGORY_COMMENT, CATEGORY_FUNCTION, CATEGORY_KEYWORD, CATEGORY_NUMBER, CATEGORY_OPERATOR,\n  CATEGORY_PROPERTY, CATEGORY_SELECTOR, CATEGORY_SPACE, CATEGORY_STRING, CATEGORY_SYMBOL, CATEGORY_TAG,\n} from '../../constants/categories';\nimport { REGEXP_MULTILINE_COMMENT, REGEXP_SPACE } from '../../constants/regexp';\n\n\n/**\n * Returns the CSS language definition.\n *\n * @return A Language object.\n */\nexport function css(): Language {\n  return {\n    id  : 'css',\n    name: 'CSS',\n\n    grammar: {\n      main: [\n        [ '#common' ],\n        [ '#findBlock' ],\n        [ '#findAtrule' ],\n      ],\n\n      findBlock: [\n        [ '#block', /[^\\s][^;{}]+{.*?}/s, '@rest' ],\n      ],\n\n      findAtrule: [\n        [ '#atrule', /@\\w.+?(;|(?=[{}]))/s ],\n      ],\n\n      findSelector: [\n        [ '#selector', /[^\\s{};/].*?(?={)/s ],\n      ],\n\n      common: [\n        [ CATEGORY_STRING, /(['\"]).*?[^\\\\]\\1/s ],\n        [ CATEGORY_COMMENT, REGEXP_MULTILINE_COMMENT ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n\n      block: [\n        [ '#findAtrule' ],\n        [ '#findSelector' ],\n        [ '#inner', /{/, '@rest' ],\n        [ CATEGORY_BRACKET, /}/, '@break' ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n\n      inner: [\n        [ CATEGORY_BRACKET, /{/ ],\n        [ '#common' ],\n        [ '#findBlock' ],\n        [ '#props' ],\n        [ '#findAtrule' ],\n        [ '', /}/, '@back' ],\n      ],\n\n      atrule: [\n        [ '#common' ],\n        [ '#url', /\\burl\\(/, '@rest' ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n        [ CATEGORY_KEYWORD, /[^\\s();]+/ ],\n        [ CATEGORY_SYMBOL, /[:;,]/ ],\n        [ '#paren', /\\(/, '@rest' ],\n      ],\n\n      paren: [\n        [ CATEGORY_BRACKET, /^\\(/ ],\n        [ '#common' ],\n        [ '#paren', /\\(/, '@rest' ],\n        [ CATEGORY_BRACKET, /\\)/, '@break' ],\n        [ '#props' ],\n      ],\n\n      selector: [\n        [ '#common' ],\n        [ CATEGORY_OPERATOR, /[>+~]/ ],\n        [ CATEGORY_BRACKET, /[[\\]()]/ ],\n        [ CATEGORY_SYMBOL, /=/ ],\n        [ CATEGORY_SELECTOR, /::?\\S+/ ],\n        [ CATEGORY_SELECTOR, /[\\W\\d]\\S+/ ],\n        [ CATEGORY_TAG, /\\b[a-zA-Z]+|\\*/ ],\n        [ CATEGORY_SELECTOR, /\\S+/ ],\n      ],\n\n      url: [\n        [ '#common' ],\n        [ CATEGORY_FUNCTION, /^url/ ],\n        [ CATEGORY_BRACKET, /\\(/ ],\n        [ CATEGORY_STRING, /[^)]+/ ],\n        [ CATEGORY_BRACKET, /\\)/, '@break' ],\n      ],\n\n      props: [\n        [ CATEGORY_PROPERTY, /[a-z0-9-]+(?=:)/i ],\n        [ '#url', /\\burl\\(/, '@rest' ],\n        [ CATEGORY_FUNCTION, /\\b[\\w-]+(?=\\()\\b/ ],\n        [ CATEGORY_KEYWORD, /!important|\\b(?:initial|inherit|unset)/ ],\n        [ CATEGORY_PROPERTY, /[a-z0-9-]+(?=:)/ ],\n        [ CATEGORY_NUMBER, /#([0-9a-f]{6}|[0-9a-f]{3})/i ],\n        [ CATEGORY_NUMBER, /\\bU\\+[0-9a-f?-]+/i ],\n        [ CATEGORY_NUMBER, /[+-]?(\\d+\\.?\\d*|\\d*\\.?\\d+)/ ],\n        [ CATEGORY_SYMBOL, /[:;,]/ ],\n        [ '#paren', /\\(/, '@rest' ],\n        [ CATEGORY_BRACKET, /[[\\])]/ ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n    },\n  };\n}\n","import { REGEXP_MULTILINE_COMMENT, REGEXP_SLASH_COMMENT } from '../../constants/regexp';\nimport { Language } from '../../types';\nimport { common } from '../common/common';\nimport {\n  CATEGORY_BRACKET, CATEGORY_COMMENT, CATEGORY_DECORATOR,\n  CATEGORY_KEYWORD, CATEGORY_STRING,\n} from '../../constants/categories';\nimport { assign, before } from '../../utils';\n\n\n/**\n * Returns the JavaScript language definition.\n *\n * @return A Language object.\n */\nexport function javascript(): Language {\n  const language = assign( common(), {\n    id   : 'javascript',\n    name : 'JavaScript',\n    alias: [ 'js' ],\n  } );\n\n  const { grammar } = language;\n  const { main }    = grammar;\n\n  before( main, CATEGORY_KEYWORD, [\n    [ CATEGORY_KEYWORD, /\\b(?:as|async|await|case|catch|const|debugger|default|delete|enum|export|from|import|let|package|private|protected|public|super|switch|static|this|typeof|undefined|var|void|with|yield)\\b/ ],\n    [ CATEGORY_KEYWORD, /\\b((get|set)(?= *\\S+\\(\\)))/ ], // todo\n    [ '#backtick', /`/, '@rest' ],\n    [ CATEGORY_DECORATOR, /@[^\\s(@]+/ ],\n  ]\n  );\n\n  assign( grammar, {\n    backtick: [\n      [ CATEGORY_STRING, /^`/ ],\n      [ '#expression', /\\${/, '@rest' ],\n      [ CATEGORY_STRING, /\\$[^{]/ ],\n      [ CATEGORY_STRING, /[^`$]+/ ],\n      [ CATEGORY_STRING, /`/, '@break' ],\n    ],\n\n    expression: [\n      [ CATEGORY_BRACKET, /^\\${/ ],\n      [ '#expression', /\\${/, '@rest' ],\n      [ CATEGORY_COMMENT, REGEXP_MULTILINE_COMMENT ],\n      [ CATEGORY_COMMENT, REGEXP_SLASH_COMMENT ],\n      [ '#backtick', /`/, '@rest' ],\n      [ CATEGORY_BRACKET, /}/, '@break' ],\n      [ '#main' ],\n    ],\n  } );\n\n  return language;\n}\n","import {\n  CATEGORY_ATTRIBUTE, CATEGORY_BRACKET, CATEGORY_COMMENT, CATEGORY_ENTITY, CATEGORY_PROLOG, CATEGORY_SPACE,\n  CATEGORY_SYMBOL, CATEGORY_TAG, CATEGORY_VALUE,\n} from '../../constants/categories';\nimport { REGEXP_SPACE } from '../../constants/regexp';\nimport { Language } from '../../types';\nimport { css } from '../css/css';\nimport { javascript } from '../javascript/javascript';\n\n\n/**\n * Returns the HTML language definition.\n *\n * @return A Language object.\n */\nexport function html(): Language {\n  return {\n    id   : 'html',\n    alias: [ 'markup' ],\n    name : 'HTML',\n\n    use: {\n      javascript: javascript(),\n      css       : css(),\n    },\n\n    grammar: {\n      main: [\n        [ CATEGORY_COMMENT, /<!--.*?-->/s ],\n        [ CATEGORY_PROLOG, /<!DOCTYPE.*?>/ ],\n        [ CATEGORY_PROLOG, /<!\\[CDATA\\[.*]]>/s ],\n        [ '#script', /<script.*?>.*?<\\/script>/s ],\n        [ '#style', /<style.*?>.*?<\\/style>/s ],\n        [ '#tag', /<.*?>/s ],\n        [ CATEGORY_ENTITY, /&[\\da-z]+;|&#\\d+;/i ],\n      ],\n\n      script: [\n        [ '#tag', /^<script.*?>/s ],\n        [ '@javascript', /.+(?=<\\/script>)/s ],\n        [ '#tag', /<\\/script>/ ],\n      ],\n\n      style: [\n        [ '#tag', /^<style.*?>/s ],\n        [ '@css', /.+(?=<\\/style>)/s ],\n        [ '#tag', /<\\/style>/ ],\n      ],\n\n      tag: [\n        [ '#attr', /\\s+.+(?=[\\s/>])/s ],\n        [ CATEGORY_TAG, /[^\\s/<>\"'=]+/ ],\n        [ CATEGORY_BRACKET, /[<>]/ ],\n        [ CATEGORY_SYMBOL, /[/]/ ],\n      ],\n\n      attr: [\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n        [ CATEGORY_VALUE, /(['\"])(\\\\\\1|.)*?\\1/ ],\n        [ CATEGORY_SYMBOL, /[/=]/ ],\n        [ CATEGORY_ATTRIBUTE, /[^\\s/>\"'=]+/ ],\n      ],\n    },\n  };\n}\n","import { Language } from '../../types';\n\n\n/**\n * Returns the None language definition.\n *\n * @return A Language object.\n */\nexport function none(): Language {\n  return {\n    id     : 'none',\n    name   : '',\n    grammar: { main: [] },\n  };\n}\n","import { Language } from '../../types';\nimport { CATEGORY_PROLOG } from '../../constants/categories';\nimport { assign } from '../../utils';\nimport { html } from '../html/html';\n\n\n/**\n * Returns the XML language definition.\n *\n * @return A Language object.\n */\nexport function xml(): Language {\n  const language = assign( html(), {\n    id   : 'xml',\n    name : 'XML',\n    alias: [],\n  } );\n\n  language.grammar.main.unshift( [ CATEGORY_PROLOG, /<\\?.*?\\?>/s ] );\n\n  return language;\n}\n","import { REGEXP_BOOLEAN, REGEXP_DOUBLE_QUOTE, REGEXP_SPACE } from '../../constants/regexp';\nimport { Language } from '../../types';\nimport {\n  CATEGORY_BOOLEAN, CATEGORY_BRACKET, CATEGORY_KEYWORD, CATEGORY_NUMBER, CATEGORY_OPERATOR,\n  CATEGORY_PROPERTY, CATEGORY_SPACE, CATEGORY_STRING, CATEGORY_SYMBOL,\n} from '../../constants/categories';\n\n\n/**\n * Returns the JSON language definition.\n *\n * @link https://www.json.org/json-en.html\n *\n * @return A Language object.\n */\nexport function json(): Language {\n  return {\n    id  : 'json',\n    name: 'JSON',\n\n    grammar: {\n      main: [\n        [ CATEGORY_PROPERTY, /\".*?[^\\\\]\"(?=:)/ ],\n        [ CATEGORY_STRING, REGEXP_DOUBLE_QUOTE ],\n        [ CATEGORY_KEYWORD, /\\bnull\\b/ ],\n        [ CATEGORY_NUMBER, /[+-]?(\\d+\\.?\\d*)([eE][+-]?\\d+)?/ ],\n        [ CATEGORY_BRACKET, /[{}[]]/ ],\n        [ CATEGORY_BOOLEAN, REGEXP_BOOLEAN ],\n        [ CATEGORY_OPERATOR, /:/ ],\n        [ CATEGORY_SYMBOL, /[,]/ ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n    },\n  };\n}\n","import { Language } from '../../types';\nimport {\n  CATEGORY_ATTRIBUTE, CATEGORY_BRACKET, CATEGORY_CLASS, CATEGORY_SPACE,\n  CATEGORY_SYMBOL, CATEGORY_TAG, CATEGORY_VALUE,\n} from '../../constants/categories';\nimport { REGEXP_SPACE } from '../../constants/regexp';\nimport { assign, before } from '../../utils';\nimport { javascript } from '../javascript/javascript';\n\n\n/**\n * Returns the JSX language definition.\n *\n * @return A Language object.\n */\nexport function jsx(): Language {\n  const language = assign( javascript(), {\n    id   : 'jsx',\n    name : 'JSX',\n    alias: [ 'react' ],\n    use  : { javascript: javascript() },\n  } );\n\n  const { grammar } = language;\n  const { main }    = grammar;\n\n  before( main, CATEGORY_CLASS, [ [ '#pickPairedTag' ], [ '#pickSelfClosedTag' ] ] );\n\n  assign( grammar, {\n    // This doesn't pick correct paired tags when they are nested, but they are incrementally searched later.\n    pickPairedTag: [\n      [ '#pairedTag', /<\\s*?([\\w]+?).*?>.*?<\\/\\1>/s, '@rest' ],\n    ],\n\n    pickSelfClosedTag: [\n      [ '#selfClosedTag', /<\\s*?([\\w]+?).*?\\/>/s ],\n    ],\n\n    pairedTag: [\n      [ '#openTag', /^</, '@rest' ],\n      [ '@javascript', /{.*?}/s ],\n      [ '#pickPairedTag' ],\n      [ '#pickSelfClosedTag' ],\n      [ '#tagName', /<\\/[\\w][^\\s]*?>/, '@break' ],\n    ],\n\n    selfClosedTag: [\n      [ '#openTag', /^</, '@rest' ],\n    ],\n\n    openTag: [\n      [ '#tagName', /<\\s*[^\\s/>\"'=]+/ ],\n      [ '@javascript', /{.*?}/s ],\n      [ CATEGORY_ATTRIBUTE, /[^\\s/>\"'=]+/ ],\n      [ CATEGORY_VALUE, /(['\"])(\\\\\\1|.)*?\\1/ ],\n      [ CATEGORY_SPACE, REGEXP_SPACE ],\n      [ CATEGORY_SYMBOL, /[/=]/ ],\n      [ CATEGORY_BRACKET, />/, '@break' ],\n    ],\n\n    tagName: [\n      [ CATEGORY_BRACKET, /[<>]/ ],\n      [ CATEGORY_SPACE, REGEXP_SPACE ],\n      [ CATEGORY_SYMBOL, /\\// ],\n      [ CATEGORY_CLASS, /[A-Z][\\w$-]*/ ],\n      [ CATEGORY_TAG, /[^\\s/>\"'=]+/ ],\n    ],\n  } );\n\n  return language;\n}\n","import { Language } from '../../types';\nimport {\n  CATEGORY_BRACKET, CATEGORY_COMMENT, CATEGORY_FUNCTION, CATEGORY_OPERATOR, CATEGORY_PROPERTY,\n  CATEGORY_SELECTOR, CATEGORY_SPACE, CATEGORY_STRING, CATEGORY_SYMBOL,\n  CATEGORY_TAG, CATEGORY_VARIABLE,\n} from '../../constants/categories';\nimport { REGEXP_MULTILINE_COMMENT, REGEXP_SLASH_COMMENT, REGEXP_SPACE } from '../../constants/regexp';\nimport { assign, before } from '../../utils';\nimport { css } from '../css/css';\n\n\n/**\n * Returns the SCSS language definition.\n *\n * @return A Language object.\n */\nexport function scss(): Language {\n  const language = assign( css(), {\n    id  : 'scss',\n    name: 'SCSS',\n  } );\n\n  const { grammar } = language;\n\n  assign( grammar, {\n    findBlock: [\n      [ '#block', /(#{[^;]*?}|[^\\s])(#{[^;]*?}|[^;{}])*[^#]{.*?}/s, '@rest' ],\n    ],\n\n    findAtrule: [\n      [ '#atrule', /@\\w.+?(;|(?=[^#]{))/s ],\n    ],\n\n    findSelector: [\n      [ '#selector', /[^\\s{};/].*?[^#](?={)/s ],\n    ],\n\n    findInterp: [\n      [ '#interp', /#{/, '@rest' ],\n    ],\n\n    common: [\n      [ '#string' ],\n      [ CATEGORY_COMMENT, REGEXP_MULTILINE_COMMENT ],\n      [ CATEGORY_COMMENT, REGEXP_SLASH_COMMENT ],\n      [ CATEGORY_SPACE, REGEXP_SPACE ],\n    ],\n\n    string: [\n      [ '#singleQuote', /'/, '@rest' ],\n      [ '#doubleQuote', /\"/, '@rest' ],\n    ],\n\n    singleQuote: [\n      [ CATEGORY_STRING, /^'/ ],\n      [ '#findInterp' ],\n      [ CATEGORY_STRING, /(\\\\'|#[^{]|[^'#])+/ ],\n      [ CATEGORY_STRING, /'/, '@break' ],\n    ],\n\n    doubleQuote: [\n      [ CATEGORY_STRING, /^\"/ ],\n      [ '#findInterp' ],\n      [ CATEGORY_STRING, /(\\\\\"|#[^{]|[^\"#])+/ ],\n      [ CATEGORY_STRING, /\"/, '@break' ],\n    ],\n\n    selector: [\n      [ '#common' ],\n      [ '#findInterp' ],\n      [ CATEGORY_OPERATOR, /[>+~]/ ],\n      [ CATEGORY_BRACKET, /[[\\]()]/ ],\n      [ CATEGORY_SYMBOL, /=/ ],\n      [ CATEGORY_SELECTOR, /::?\\S+(?=#{)/ ],\n      [ CATEGORY_SELECTOR, /[\\W\\d]\\S+(?=#{)/ ],\n      [ CATEGORY_TAG, /\\b[a-zA-Z]+\\b|\\*/ ],\n      [ CATEGORY_SELECTOR, /\\S+/ ],\n    ],\n\n    url: [\n      [ '#common' ],\n      [ '#findInterp' ],\n      [ CATEGORY_FUNCTION, /^url/ ],\n      [ CATEGORY_BRACKET, /\\(/ ],\n      [ CATEGORY_STRING, /[^)]+(?=#{)/ ],\n      [ CATEGORY_STRING, /[^)]+/ ],\n      [ CATEGORY_BRACKET, /\\)/, '@break' ],\n    ],\n\n    interp: [\n      [ CATEGORY_BRACKET, /#{/ ],\n      [ CATEGORY_BRACKET, /}/, '@break' ],\n      [ '#common' ],\n      [ '#props' ],\n    ],\n  } );\n\n  grammar.inner.unshift( [ '#findInterp' ] );\n\n  before( grammar.atrule, '#url', [ [ '#findInterp' ] ] );\n  before( grammar.props, CATEGORY_PROPERTY, [\n    [ '#findInterp' ],\n    [ CATEGORY_VARIABLE, /\\$[\\w-_]+/ ],\n  ] );\n\n  return language;\n}\n","import { Language } from '../../types';\nimport { assign } from '../../utils';\nimport { xml } from '../xml/xml';\n\n\n/**\n * Returns the XML language definition.\n *\n * @return A Language object.\n */\nexport function svg(): Language {\n  return assign( xml(), {\n    id   : 'svg',\n    name : 'SVG',\n    alias: [],\n  } );\n}\n","import { Language } from '../../types';\nimport { CATEGORY_FUNCTION, CATEGORY_KEYWORD } from '../../constants/categories';\nimport { assign, before } from '../../utils';\nimport { javascript } from '../javascript/javascript';\n\n\n/**\n * Returns the Typescript language definition.\n *\n * @return A Language object.\n */\nexport function typescript(): Language {\n  const language = assign( javascript(), {\n    id   : 'typescript',\n    name : 'TypeScript',\n    alias: [ 'ts' ],\n  } );\n\n  const { grammar } = language;\n  const { main }    = grammar;\n\n  before( main, CATEGORY_KEYWORD, [\n    [\n      CATEGORY_KEYWORD,\n      /\\b(?:declare|keyof|namespace|readonly|type|string|number|boolean|bigint|symbol|object|any|never|unknown|infer)\\b/,\n    ],\n  ] );\n\n  before( main, CATEGORY_FUNCTION, [ [ '#functions', /([\\w$]+)?(?:<[^>]+?>)?\\s*?\\(/ ] ] );\n\n  assign( grammar, {\n    functions: [\n      [ CATEGORY_FUNCTION, /^[\\w$]+/ ],\n      // Avoid circular references(\"main\" has #functions).\n      ...main.filter( tokenizer => tokenizer[ 0 ] !== '#functions' ),\n    ],\n  } );\n\n  return language;\n}\n","import { Language } from '../../types';\nimport { assign } from '../../utils';\nimport { html } from '../html/html';\n\n\n/**\n * Returns the VUE language definition.\n *\n * @return A Language object.\n */\nexport function vue(): Language {\n  const language = assign( html(), { id: 'vue', name: 'Vue', alias: [] } );\n\n  // Vue uses Mustache syntax for writing code inside tags.\n  language.grammar.main.push( [ '@javascript', /{{[\\s\\S]*?}}/ ] );\n\n  return language;\n}\n","import { Language, Options, Token } from '../../types';\nimport { Lexer } from '../Lexer/Lexer';\nimport { Renderer } from '../Renderer/Renderer';\nimport { CLASSES } from '../../constants/classes';\nimport { ATTRIBUTE_LANGUAGE } from '../../constants/attributes';\nimport { attr, isHTMLElement, text, assert, isString, assign, addClass, toArray } from '../../utils';\nimport { none } from '../../languages';\n\n\n/**\n * Stores all Lexer instances.\n */\nconst lexers: Record<string, Lexer> = {};\n\n/**\n * The class that tokenizes code for syntax highlighting.\n *\n * @since 0.0.1\n */\nexport class RyuseiLight {\n  /**\n   * Registers languages.\n   *\n   * @param languages - A Language object or objects.\n   */\n  static register( languages: Language | Language[] ): void {\n    toArray( languages ).forEach( language => {\n      const { id } = language;\n\n      if ( id && ! lexers[ id ] ) {\n        const lexer = new Lexer( language );\n\n        ( language.alias || [] ).concat( id ).forEach( id => {\n          lexers[ id ] = lexer;\n        } );\n      }\n    } );\n  }\n\n  /**\n   * Adds components.\n   *\n   * @param components - An object literal with Component functions.\n   */\n  static compose = Renderer.compose;\n\n  /**\n   * Tokenizes the provided string.\n   *\n   * @param code     - A string to tokenize.\n   * @param language - A language ID.\n   *\n   * @return An array of arrays with tokens as [ string, string ].\n   */\n  static tokenize( code: string, language: string ): Token[][] {\n    return RyuseiLight.getLexer( language ).tokenize( code );\n  }\n\n  /**\n   * Returns a registered Lexer instance.\n   * If it's not found, the `none` lexer will be returned.\n   *\n   * @param language - A language name.\n   */\n  protected static getLexer( language: string ) {\n    if ( ! lexers.none ) {\n      RyuseiLight.register( none() );\n    }\n\n    return lexers[ language ] || lexers.none;\n  }\n\n  /**\n   * Holds all renderers.\n   */\n  protected readonly renderers: Renderer[] = [];\n\n  /**\n   * Holds options.\n   */\n  protected readonly options: Options;\n\n  /**\n   * The RyuseiLight constructor.\n   *\n   * @param options  - Optional. Options.\n   */\n  constructor( options: Options = {} ) {\n    this.options = assign( {}, options );\n  }\n\n  /**\n   * Returns a new Renderer instance.\n   *\n   * @param code    - A code to highlight.\n   * @param elm     - Optional. An element to highlight.\n   * @param options - Optional. Options.\n   */\n  protected getRenderer( code: string, elm?: HTMLElement, options: Options = {} ) {\n    options = assign( {}, this.options, options );\n\n    const language     = options.language;\n    const { name, id } = RyuseiLight.getLexer( language ).language;\n    return new Renderer( RyuseiLight.tokenize( code, language ), { name, id }, elm, options );\n  }\n\n  /**\n   * Applies the highlighter to elements that matches the selector or the provided element.\n   *\n   * @param target  - A selector or an element.\n   * @param options - Optional. Options.\n   */\n  apply( target: string | Element, options: Options = {} ): void {\n    const elms = isString( target ) ? document.querySelectorAll( target ) : [ target ];\n\n    for ( let i = 0; i < elms.length; i++ ) {\n      const elm = elms[ i ];\n\n      if ( isHTMLElement( elm ) ) {\n        options.language = attr( elm, ATTRIBUTE_LANGUAGE ) || options.language;\n\n        const renderer = this.getRenderer( text( elm ), elm, options );\n        const isPre    = elm instanceof HTMLPreElement;\n\n        if ( isPre ) {\n          addClass( elm, [ CLASSES.root, `${ CLASSES.root }--${ renderer.info.id }` ] );\n        }\n\n        elm.innerHTML = renderer.html( ! isPre );\n\n        this.renderers.push( renderer );\n      }\n    }\n  }\n\n  /**\n   * Returns highlighted HTML by tokenizing the provided code.\n   *\n   * @param code    - Code to highlight.\n   * @param options - Optional. Options.\n   *\n   * @return Highlighted HTML string.\n   */\n  html( code: string, options: Options = {} ): string {\n    assert( isString( code ), 'Invalid code.' );\n    return this.getRenderer( code, null, options ).html();\n  }\n\n  /**\n   * Destroys the instance.\n   */\n  destroy(): void {\n    this.renderers.forEach( renderer => {\n      renderer.destroy();\n    } );\n  }\n}\n","import { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { Renderer } from '../../core/Renderer/Renderer';\nimport { CLASSES } from '../../constants/classes';\nimport { attr, error, isArray } from '../../utils';\n\n\n/**\n * The data attribute name for active lines.\n * The value must be an array in JSON format, such as \"[ 2, [ 5, 10 ] ]\"\n *\n * @since 0.0.1\n */\nconst ATTRIBUTE_ACTIVE_LINES = `data-${ PROJECT_CODE_SHORT }-active-lines`;\n\n/**\n * The component for highlighting lines.\n *\n * @since 0.0.1\n */\nexport function ActiveLines( { event, root, options }: Renderer ): void {\n  const lines = ( root && parseData( root ) ) || options.activeLines;\n\n  if ( isArray( lines ) ) {\n    const activeLines = normalize( lines );\n\n    event.on( 'gutter:row:open', ( html, classes, index ) => {\n      if ( activeLines[ index ] ) {\n        classes.push( activeLines[ index ] );\n      }\n    } );\n\n    event.on( 'line:open', ( html, classes, index ) => {\n      if ( activeLines[ index ] ) {\n        classes.push( activeLines[ index ] );\n      }\n    } );\n  }\n}\n\n/**\n * Attempts to get definition of active lines from a data attribute.\n *\n * @param elm - A root element.\n *\n * @return An array with line numbers if available, or otherwise `undefined`.\n */\nfunction parseData( elm: HTMLElement ): Array<number | [ number, number ]> | void {\n  const data = attr( elm, ATTRIBUTE_ACTIVE_LINES );\n\n  if ( data ) {\n    try {\n      return JSON.parse( data );\n    } catch ( e ) {\n      error( e.message );\n    }\n  }\n}\n\n/**\n * Normalizes the definition of lines to activate.\n *\n * @param lines - An array with line numbers.\n *\n * @return An array with normalized line numbers.\n */\nfunction normalize( lines: Array<number | [ number, number ]> ): string[] {\n  const numbers = [];\n\n  lines.forEach( range => {\n    if ( ! isArray( range ) ) {\n      range = [ range, range ];\n    }\n\n    const start = ( +range[ 0 ] || 1 ) - 1;\n    const end   = ( +range[ 1 ] || 1 ) - 1;\n\n    for ( let i = start; i <= end; i++ ) {\n      numbers[ i ] = CLASSES.active;\n    }\n  } );\n\n  return numbers;\n}\n","import { PROJECT_CODE } from '../../../constants/project';\n\n\n/**\n * Displays an error message on the console.\n *\n * @param message - An error message.\n */\nexport function error( message: string ): void {\n  console.error( `[${ PROJECT_CODE }] ${ message }` );\n}\n","import { Renderer } from '../../core/Renderer/Renderer';\nimport { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { CLASSES } from '../../constants/classes';\nimport { styles, throttle, isHTMLElement, query } from '../../utils';\n\n\n/**\n * The throttle duration in milliseconds for resizing gutter rows.\n *\n * @since 0.0.1\n */\nconst THROTTLE_DURATION = 100;\n\n/**\n * The class name for a gutter element.\n *\n * @since 0.0.1\n */\nconst GUTTER_CLASS_NAME = `${ PROJECT_CODE_SHORT }__gutter`;\n\n/**\n * The class name for row element in a gutter.\n *\n * @since 0.0.1\n */\nconst GUTTER_ROW_CLASS_NAME = `${ GUTTER_CLASS_NAME }__row`;\n\n/**\n * The component for creating a gutter and its rows.\n * This is usually activated by other components through the `gutter` option.\n *\n * @since 0.0.1\n */\nexport function Gutter( { lines, event, root, options }: Renderer ): void {\n  // Wait for initialization of other components.\n  event.on( 'mounted', () => {\n    if ( ! options.gutter ) {\n      return;\n    }\n\n    event.on( 'open', ( append, classes ) => {\n      classes.push( 'has-gutter' );\n    } );\n\n    event.on( 'body:opened', append => {\n      append( `<div class=\"${ GUTTER_CLASS_NAME }\" aria-hidden=\"true\">` );\n\n      for ( let i = 0; i < lines.length; i++ ) {\n        const classes = [ GUTTER_ROW_CLASS_NAME ];\n        event.emit( 'gutter:row:open', append, classes, i );\n\n        append( `<div class=\"${ classes.join( ' ' ) }\">` );\n        event.emit( 'gutter:row:opened', append, i );\n        append( `</div>` );\n      }\n\n      append( `</div>` );\n    } );\n\n    if ( ! root || typeof window === 'undefined' ) {\n      return;\n    }\n\n    window.addEventListener( 'resize', throttle( resize, THROTTLE_DURATION ) );\n    resize();\n\n    event.on( 'destroy', () => {\n      window.removeEventListener( 'resize', resize );\n    } );\n\n    /**\n     * Resizes rows according to line height.\n     */\n    function resize() {\n      const gutter = query( `.${ GUTTER_CLASS_NAME }`, root );\n      const code   = query( `.${ CLASSES.code }`, root );\n\n      if ( gutter && code ) {\n        for ( let i = 0; i < code.children.length; i++ ) {\n          const row  = gutter.children[ i ];\n          const line = code.children[ i ];\n\n          if ( isHTMLElement( row ) && row.clientHeight !== line.clientHeight ) {\n            styles( row, { height: `${ line.clientHeight }px` } );\n          }\n        }\n      }\n    }\n  } );\n}\n","import { AnyFunction } from '../../../types';\n\n\n/**\n * Returns a function that invokes the provided function at most once in the specified duration.\n *\n * @since 0.0.1\n *\n * @param callback - A function to throttle.\n * @param interval - A throttle duration in milliseconds.\n *\n * @return A throttled function.\n */\nexport function throttle( callback: AnyFunction, interval: number ): () => void {\n  let timer;\n\n  return function () {\n    if ( ! timer ) {\n      timer = setTimeout( () => {\n        callback();\n        timer = null;\n      }, interval );\n    }\n  };\n}\n","import { Renderer } from '../../core/Renderer/Renderer';\nimport { PROJECT_CODE_SHORT } from '../../constants/project';\n\n\n/**\n * The component for rendering a language name.\n *\n * @since 0.0.1\n */\nexport function LanguageName( { event, info, options }: Renderer ) {\n  const { name } = info;\n\n  if ( options.languageName && name ) {\n    const position = options.languageName === 'topLeft' ? 'topLeft' : 'topRight';\n    options.overlay = options.overlay || {};\n    options.overlay[ position ] = true;\n\n    event.on( `overlay:${ position }`, append => {\n      append( `<span class=\"${ PROJECT_CODE_SHORT }__name\">${ info.name }</span>` );\n    } );\n  }\n}\n","import { Renderer } from '../../core/Renderer/Renderer';\nimport { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { attr } from '../../utils';\n\n\n/**\n * The data attribute name for line numbers.\n * This accepts boolean or number as a value.\n *\n * @since 0.0.1\n */\nconst ATTRIBUTE_LINE_NUMBERS = `data-${ PROJECT_CODE_SHORT }-line-numbers`;\n\n/**\n * The component for displaying line numbers in a gutter.\n *\n * @since 0.0.1\n */\nexport function LineNumbers( { root, event, options }: Renderer ): void {\n  const data   = root ? attr( root, ATTRIBUTE_LINE_NUMBERS ) : '';\n  const number = data === '' ? +options.lineNumbers : +data;\n\n  if ( number || number === 0 ) {\n    options.gutter = true;\n    const start = Math.floor( number ) - 1;\n\n    event.on( 'gutter:row:opened', ( append, i ) => {\n      append( `<span class=\"${ PROJECT_CODE_SHORT }__line-number\">${ i + 1 + start }</span>` );\n    } );\n  }\n}\n","import { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { Renderer } from '../../core/Renderer/Renderer';\n\n\n/**\n * The component for rendering overlay elements.\n *\n * @since 0.0.1\n */\nexport function Overlay( { event, options }: Renderer ) {\n  event.on( 'mounted', () => {\n    const className = `${ PROJECT_CODE_SHORT }__overlay`;\n    const { overlay = {} } = options;\n\n    if ( overlay.topRight || options.tools ) {\n      event.on( 'close', append => {\n        append( `<div class=\"${ className } ${ className }--top-right\">` );\n        event.emit( 'overlay:topRight', append );\n\n        if ( options.tools ) {\n          append( `<div class=\"${ PROJECT_CODE_SHORT }__tools\">` );\n          event.emit( 'overlay:tools', append );\n          append( `</div>` );\n        }\n\n        append( `</div>` );\n      } );\n    }\n\n    if ( overlay.topLeft ) {\n      event.on( 'close', append => {\n        append( `<div class=\"${ className } ${ className }--top-left\">` );\n        event.emit( 'overlay:topLeft', append );\n        append( `</div>` );\n      } );\n    }\n\n    if ( overlay.topRight || overlay.topLeft ) {\n      event.on( 'open', ( append, classes ) => {\n        classes.push( 'has-top-overlay' );\n      } );\n    }\n  } );\n}\n","import { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { Renderer } from '../../core/Renderer/Renderer';\nimport { attr } from '../../utils';\n\n\n/**\n * The data attribute name for a title.\n *\n * @since 0.0.1\n */\nconst ATTRIBUTE_TITLE = `data-${ PROJECT_CODE_SHORT }-title`;\n\n/**\n * The component for rendering a title in a header.\n *\n * @since 0.0.1\n */\nexport function Title( { event, root, options }: Renderer ) {\n  const title = ( root && attr( root, ATTRIBUTE_TITLE ) ) || options.title;\n\n  if ( title ) {\n    event.on( 'open', append => {\n      append( `<div class=\"${ PROJECT_CODE_SHORT }__header\">` );\n      append( `<span class=\"${ PROJECT_CODE_SHORT }__title\">${ title }</span>` );\n      append( `</div>` );\n    } );\n  }\n}\n","import { RyuseiLight } from '../core/RyuseiLight/RyuseiLight';\nimport * as languages  from '../languages';\nimport * as components from '../components';\nimport { forOwn } from '../utils';\n\nforOwn( languages, language => {\n  RyuseiLight.register( language() );\n} );\n\nRyuseiLight.compose( components );\n\nexport { RyuseiLight as default } from '../core/RyuseiLight/RyuseiLight';\n"],"names":["CATEGORY_KEYWORD","CATEGORY_COMMENT","CATEGORY_TAG","CATEGORY_SELECTOR","CATEGORY_ATTRIBUTE","CATEGORY_PROPERTY","CATEGORY_VALUE","CATEGORY_PROLOG","CATEGORY_STRING","CATEGORY_NUMBER","CATEGORY_BOOLEAN","CATEGORY_FUNCTION","CATEGORY_CLASS","CATEGORY_OPERATOR","CATEGORY_BRACKET","CATEGORY_SYMBOL","CATEGORY_SPACE","CATEGORY_TEXT","isArray","subject","Array","isString","isUndefined","isHTMLElement","HTMLElement","toArray","value","addClass","elm","classes","forEach","name","classList","add","forOwn","object","iteratee","keys","Object","i","length","assign","sources","source","key","attr","attrs","getAttribute","setAttribute","String","query","selector","parent","document","querySelector","styles","style","text","node","textContent","assert","condition","message","Error","PROJECT_CODE","before","map","ref","entries","index","find","splice","push","startsWith","string","char","charAt","isStickySupported","sticky","Lexer","language","init","grammar","tokenizers","_this","merge","use","this","bind","reduce","merged","tokenizer","category","regexp","include","slice","_this2","flags","toString","match","getFlags","replace","RegExp","tokenizeBy","position","main","command","lastIndex","exec","handle","token","from","indexOf","lines","offset","lang","input","tokenize","EventBus","on","event","callback","handlers","emit","args","handler","destroy","CLASSES","root","container","PROJECT_CODE_SHORT","body","code","line","active","Components","Renderer","info","options","compose","components","Component","tokens","trim","pop","_this3","renderLines","append","tag","span","join","j","html","pre","fragment","id","containerClasses","bodyClasses","wrap","REGEXP_FUNCTION","REGEXP_NUMBER","REGEXP_BOOLEAN","REGEXP_BRACKET","REGEXP_SPACE","REGEXP_QUOTE","REGEXP_DOUBLE_QUOTE","REGEXP_MULTILINE_COMMENT","REGEXP_SLASH_COMMENT","common","css","findBlock","findAtrule","findSelector","block","inner","atrule","paren","url","props","javascript","alias","backtick","expression","script","none","xml","unshift","pickPairedTag","pickSelfClosedTag","pairedTag","selfClosedTag","openTag","tagName","findInterp","singleQuote","doubleQuote","interp","functions","filter","lexers","RyuseiLight","register","languages","lexer","concat","getLexer","getRenderer","apply","target","elms","querySelectorAll","renderer","isPre","HTMLPreElement","innerHTML","renderers","ATTRIBUTE_ACTIVE_LINES","data","JSON","parse","e","console","error","parseData","activeLines","numbers","range","start","end","normalize","interval","timer","gutter","GUTTER_CLASS_NAME","window","addEventListener","resize","setTimeout","removeEventListener","children","row","clientHeight","height","languageName","overlay","number","lineNumbers","Math","floor","topRight","tools","topLeft","title"],"mappings":"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"}