{"version":3,"file":"ryuseilight.min.js","sources":["../../src/js/constants/categories.ts","../../src/js/utils/type/type.ts","../../src/js/utils/array/toArray/toArray.ts","../../src/js/utils/dom/addClass/addClass.ts","../../src/js/utils/object/forOwn/forOwn.ts","../../src/js/utils/object/assign/assign.ts","../../src/js/utils/dom/attr/attr.ts","../../src/js/utils/dom/tag/tag.ts","../../src/js/utils/dom/text/text.ts","../../src/js/utils/error/assert/assert.ts","../../src/js/utils/string/startsWith/startsWith.ts","../../src/js/core/Lexer/Lexer.ts","../../src/js/constants/characters.ts","../../src/js/event/EventBus.ts","../../src/js/constants/classes.ts","../../src/js/constants/project.ts","../../src/js/core/Renderer/Renderer.ts","../../src/js/utils/string/escapeHtml/escapeHtml.ts","../../src/js/constants/regexp.ts","../../src/js/languages/css/css.ts","../../src/js/languages/javascript/javascript.ts","../../src/js/languages/html/html.ts","../../src/js/languages/xml/xml.ts","../../src/js/core/RyuseiLight/RyuseiLight.ts","../../src/js/languages/none/none.ts","../../src/js/build/default.ts"],"sourcesContent":["export const CATEGORY_KEYWORD    = 'keyword';\nexport const CATEGORY_CONSTANT   = 'constant';\nexport const CATEGORY_COMMENT    = 'comment';\nexport const CATEGORY_TAG        = 'tag';\nexport const CATEGORY_SELECTOR   = 'selector';\nexport const CATEGORY_ATRULE     = 'atrule';\nexport const CATEGORY_ATTRIBUTE  = 'attr';\nexport const CATEGORY_PROPERTY   = 'prop';\nexport const CATEGORY_VALUE      = 'value';\nexport const CATEGORY_VARIABLE   = 'variable';\nexport const CATEGORY_ENTITY     = 'entity';\nexport const CATEGORY_CDATA      = 'cdata';\nexport const CATEGORY_PROLOG     = 'prolog';\nexport const CATEGORY_IDENTIFIER = 'identifier';\nexport const CATEGORY_STRING     = 'string';\nexport const CATEGORY_NUMBER     = 'number';\nexport const CATEGORY_BOOLEAN    = 'boolean';\nexport const CATEGORY_FUNCTION   = 'function';\nexport const CATEGORY_CLASS      = 'class';\nexport const CATEGORY_DECORATOR  = 'decorator';\nexport const CATEGORY_REGEXP     = 'regexp';\nexport const CATEGORY_OPERATOR   = 'operator';\nexport const CATEGORY_BRACKET    = 'bracket';\nexport const CATEGORY_DELIMITER  = 'delimiter';\nexport const CATEGORY_SYMBOL     = 'symbol';\nexport const CATEGORY_SPACE      = 'space';\nexport const CATEGORY_TEXT       = 'text';\n","/**\n * Checks if the given subject is an object or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is an object, or otherwise `false`.\n */\nexport function isObject<T extends object>( subject: any ): subject is T {\n  return subject !== null && typeof subject === 'object';\n}\n\n/**\n * Checks if the given subject is an array or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is an array, or otherwise `false`.\n */\nexport function isArray<T>( subject: any ): subject is T[] {\n  return Array.isArray( subject );\n}\n\n/**\n * Checks if the given subject is a function or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is a function, or otherwise `false`.\n */\nexport function isFunction( subject: any ): subject is ( ...args: any[] ) => any {\n  return typeof subject === 'function';\n}\n\n/**\n * Checks if the given subject is a string or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is a string, or otherwise `false`.\n */\nexport function isString( subject: any ): subject is string {\n  return typeof subject === 'string';\n}\n\n/**\n * Checks if the given subject is `undefined` or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is `undefined`, or otherwise `false`.\n */\nexport function isUndefined( subject: any ): subject is undefined {\n  return typeof subject === 'undefined';\n}\n\n/**\n * Checks if the given subject is an HTMLElement instance or not.\n *\n * @param subject - A subject to check.\n *\n * @return `true` if the subject is an HTMLElement instance, or otherwise `false`.\n */\nexport function isHTMLElement( subject: any ): subject is HTMLElement {\n  return subject instanceof HTMLElement;\n}\n","import { isArray } from '../../type/type';\n\n\n/**\n * Push the provided value to an array only if the value is not an array.\n *\n * @param value - A value to push.\n *\n * @return An array containing the value, or the value itself if it is already an array.\n */\nexport function toArray<T>( value: T | T[] ): T[] {\n  return isArray<T>( value ) ? value : [ value ];\n}\n","import { toArray } from '../../array';\n\n\n/**\n * Adds classes to the element.\n *\n * @param elm     - An element to add classes to.\n * @param classes - Classes to add.\n */\nexport function addClass( elm: HTMLElement, classes: string | string[] ): void {\n  toArray( classes ).forEach( name => {\n    if ( name ) {\n      elm.classList.add( name );\n    }\n  } );\n}\n","/**\n * Iterates over the provided object by own enumerable keys with calling the iteratee function.\n *\n * @param object   - An object to iterate over.\n * @param iteratee - An iteratee function that takes the value and key as arguments.\n *\n * @return A provided object itself.\n */\nexport function forOwn<T extends object>( object: T, iteratee: ( value: T[ keyof T ], key: string ) => void ) {\n  if ( object ) {\n    const keys = Object.keys( object );\n\n    for ( let i = 0; i < keys.length; i++ ) {\n      iteratee( object[ keys[ i ] ], keys[ i ] );\n    }\n  }\n}\n","import { isObject, isUndefined } from '../../type/type';\nimport { forOwn } from '../forOwn/forOwn';\n\n\n/**\n * Assign U to T.\n *\n * @typeParam T - An object to assign to.\n * @typeParam U - An object to assign.\n *\n * @return An assigned object type.\n */\nexport type Assign<T, U> = Omit<T, keyof U> & U;\n\nexport function assign<T extends object>( object: T ): T;\n\n// There is a way to type arguments recursively, but these fixed definitions are enough for this project.\nexport function assign<T extends object, U extends object>( object: T, source: U ): Assign<T, U>;\n\nexport function assign<T extends object, U1 extends object, U2 extends object>(\n  object: T, source1: U1, source2: U2\n): Assign<Assign<T, U1>, U2>;\n\nexport function assign<T extends object, U1 extends object, U2 extends object, U3 extends object>(\n  object: T, source1: U1, source2: U2, source3: U3\n): Assign<Assign<Assign<T, U1>, U2>, U3>;\n\n/**\n * Assigns all own enumerable properties of all source objects to the provided object.\n * `undefined` in source objects will be skipped.\n *\n * @param object  - An object to assign properties to.\n * @param sources - Objects to assign properties from.\n *\n * @return An object assigned properties of the sources to.\n */\nexport function assign<T extends object, U extends object>( object: T, ...sources: U[] ): any {\n  sources.forEach( source => {\n    if ( isObject( source ) ) {\n      forOwn( source, ( value, key ) => {\n        if ( ! isUndefined( source[ key ] ) ) {\n          object[ key ] = source[ key ];\n        }\n      } );\n    }\n  } );\n\n  return object;\n}\n","import { forOwn } from '../../object';\nimport { isObject, isString } from '../../type/type';\n\n\nexport function attr( elm: Element, attrs: string ): string;\nexport function attr( elm: Element, attrs: Record<string, string | number | boolean> ): void;\n\n/**\n * Sets new attributes to the passed element if the `attrs` is an object literal,\n * or gets an attribute value from it if the `attrs` is a string.\n *\n * @param elm   - An element to set or get an attribute.\n * @param attrs - An attribute name as a string or new attributes as an object literal.\n */\nexport function attr( elm: Element, attrs: string | Record<string, string | number | boolean> ): string | void {\n  if ( isString( attrs ) ) {\n    return elm.getAttribute( attrs ) || '';\n  }\n\n  if ( isObject( attrs ) ) {\n    forOwn( attrs, ( value, key ) => {\n      elm.setAttribute( key, String( value ) );\n    } );\n  }\n}\n","/**\n * Returns an open tag with provided classes.\n *\n * @param classes - Classes.\n * @param tag     - Optional. A tag name.\n */\nexport function tag( classes: string[], tag?: string ): string {\n  return `<${ tag || 'div' } class=\"${ classes.join( ' ' ) }\">`;\n}\n","import { isUndefined } from '../../type/type';\n\n\nexport function text( node: Node ): string;\nexport function text( node: Node, text: string ): void;\n\n/**\n * Sets or gets a text content of the provided node.\n *\n * @param node - A node to get or set a text.\n * @param text - Optional. A text to set.\n */\nexport function text( node: Node, text?: string ): string | void {\n  if ( isUndefined( text ) ) {\n    return node.textContent;\n  }\n\n  node.textContent = text;\n}\n","/**\n * Throws an error if the provided condition is falsy.\n *\n * @param condition - If falsy, an error is thrown.\n * @param message   - Optional. A message for the error.\n */\nexport function assert( condition: any, message = '' ): void {\n  if ( ! condition ) {\n    throw new Error( message );\n  }\n}\n","/**\n * Checks if the string starts with the `char` or not.\n *\n * @param string - A string to check.\n * @param char   - A character.\n *\n * @return `true` if the string starts with the `char`, or otherwise `false`.\n */\nexport function startsWith( string: string, char: string ): boolean {\n  return string.charAt( 0 ) === char;\n}\n","import { Language, Token, Tokenizer } from '../../types';\r\nimport { LINE_BREAK } from '../../constants/characters';\r\nimport { CATEGORY_TEXT } from '../../constants/categories';\r\nimport { assert, forOwn, isUndefined, startsWith } from '../../utils';\r\n\r\n\r\n/**\r\n * Checks if the RegExp supports the sticky flag or not.\r\n */\r\nconst isStickySupported = ! isUndefined( /x/.sticky );\r\n\r\n/**\r\n * The class for creating a simple lexer by a Language object.\r\n *\r\n * @since 0.0.1\r\n */\r\nexport class Lexer {\r\n  /**\r\n   * Holds the Language object.\r\n   */\r\n  readonly language: Language;\r\n\r\n  /**\r\n   * Stores lines.\r\n   */\r\n  protected lines: Token[][];\r\n\r\n  /**\r\n   * Indicates the current line index.\r\n   */\r\n  protected index: number;\r\n\r\n  /**\r\n   * The depth of the state.\r\n   */\r\n  protected depth = 0;\r\n\r\n  /**\r\n   * Limits the (ideal) number of lines.\r\n   */\r\n  protected limit = 0;\r\n\r\n  /**\r\n   * Turned to be `true` if the tokenization is manually aborted.\r\n   */\r\n  protected aborted;\r\n\r\n  /**\r\n   * The Lexer constructor.\r\n   *\r\n   * @param language - A Language object.\r\n   */\r\n  constructor( language: Language ) {\r\n    this.language = language;\r\n    this.init( language );\r\n  }\r\n\r\n  /**\r\n   * Initializes the language object.\r\n   *\r\n   * @param language - A Language object to initialize.\r\n   */\r\n  protected init( language: Language ): void {\r\n    forOwn( language.grammar, ( tokenizers, key ) => {\r\n      language.grammar[ key ] = this.merge( language, tokenizers );\r\n    } );\r\n\r\n    forOwn( language.use, this.init.bind( this ) );\r\n  }\r\n\r\n  /**\r\n   * Includes tokenizers required by `#` annotation and flatten them.\r\n   *\r\n   * @param language   - A language object.\r\n   * @param tokenizers - Tokenizers.\r\n   *\r\n   * @return Merged tokenizers.\r\n   */\r\n  protected merge( language: Language, tokenizers: Tokenizer[] ): Tokenizer[] {\r\n    const merged = [];\r\n\r\n    for ( let i = 0; i < tokenizers.length; i++ ) {\r\n      const tokenizer = tokenizers[ i ];\r\n      const [ category, regexp ] = tokenizers[ i ];\r\n\r\n      if ( startsWith( category, '#' ) && ! regexp ) {\r\n        merged.push( ...this.merge( language, language.grammar[ category.slice( 1 ) ] ) );\r\n      } else {\r\n        const flags = regexp.toString().match( /[gimsy]*$/ )[ 0 ].replace( /[gy]/g, '' );\r\n        let source = regexp.source + ( isStickySupported ? '' : '|()' );\r\n\r\n        forOwn( language.source, ( replacement, key ) => {\r\n          source = source.replace( new RegExp( `%${ key }`, 'g' ), replacement.source );\r\n        } );\r\n\r\n        tokenizer[ 1 ] = new RegExp( source, ( isStickySupported ? 'y' : 'g' ) + flags );\r\n        merged.push( tokenizer );\r\n      }\r\n    }\r\n\r\n    return merged;\r\n  }\r\n\r\n  /**\r\n   * Parses the text by the provided language and tokenizers.\r\n   *\r\n   * @param text       - A text to tokenize.\r\n   * @param language   - A Grammar object.\r\n   * @param tokenizers - An array with tokenizers.\r\n   *\r\n   * @return An index of the text where the handling ends.\r\n   */\r\n  protected parse( text: string, language: Language, tokenizers: Tokenizer[] ): number {\r\n    let index    = 0;\r\n    let position = 0;\r\n\r\n\r\n    main:\r\n    while ( index < text.length && ! this.aborted ) {\r\n      for ( let i = 0; i < tokenizers.length; i++ ) {\r\n        const tokenizer = tokenizers[ i ];\r\n        const [ , regexp, action ] = tokenizer;\r\n\r\n        regexp.lastIndex = index;\r\n\r\n        const match = regexp.exec( text );\r\n\r\n        if ( ! match || ! match[ 0 ] ) {\r\n          continue;\r\n        }\r\n\r\n        if ( position < index ) {\r\n          this.push( [ CATEGORY_TEXT, text.slice( position, index ) ] );\r\n        }\r\n\r\n        if ( action === '@back' ) {\r\n          position = index;\r\n          break main;\r\n        }\r\n\r\n        const offset = this.handle( match, language, tokenizer );\r\n        index += offset || 1;\r\n        position = index;\r\n\r\n        if ( action === '@break' ) {\r\n          this.depth--;\r\n          break main;\r\n        }\r\n\r\n        continue main;\r\n      }\r\n\r\n      index++;\r\n    }\r\n\r\n    if ( position < index ) {\r\n      this.push( [ CATEGORY_TEXT, text.slice( position ) ] );\r\n    }\r\n\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Pushes the provided token to the lines array.\r\n   *\r\n   * @param token - A token to push.\r\n   */\r\n  protected push( token: Token ): void {\r\n    const [ category, text ] = token;\r\n\r\n    let index = 0;\r\n    let from  = 0;\r\n\r\n    while ( index > -1 && ! this.aborted ) {\r\n      index = text.indexOf( LINE_BREAK, from );\r\n\r\n      const sliced = text.slice( from, index < 0 ? undefined : index );\r\n\r\n      if ( sliced ) {\r\n        this.lines[ this.index ].push( [ category, sliced, this.depth ] );\r\n      }\r\n\r\n      if ( index > -1 ) {\r\n        this.index++;\r\n        this.aborted = this.limit && ! this.depth && this.index >= this.limit;\r\n\r\n        if ( ! this.aborted ) {\r\n          from = index + 1;\r\n          this.lines[ this.index ] = [];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles the matched text.\r\n   *\r\n   * @param match     - A matched result.\r\n   * @param language  - A Language object.\r\n   * @param tokenizer - A tokenizer that has been matched with the text.\r\n   *\r\n   * @return An index of the text where the handling ends.\r\n   */\r\n  protected handle( match: RegExpExecArray, language: Language, tokenizer: Tokenizer ): number {\r\n    const [ category ] = tokenizer;\r\n\r\n    if ( ! category ) {\r\n      return 0;\r\n    }\r\n\r\n    let [ text ] = match;\r\n\r\n    if ( tokenizer[ 3 ] === '@debug' ) {\r\n      // eslint-disable-next-line\r\n      console.log( text, tokenizer );\r\n    }\r\n\r\n    if ( startsWith( category, '@' ) ) {\r\n      assert( language.use );\r\n\r\n      const lang = language.use[ category.slice( 1 ) ];\r\n      assert( lang );\r\n\r\n      return this.parse( text, lang, lang.grammar.main );\r\n    }\r\n\r\n    if ( startsWith( category, '#' ) ) {\r\n      const tokenizers = language.grammar[ category.slice( 1 ) ];\r\n      assert( tokenizers );\r\n\r\n      if ( tokenizer[ 2 ] === '@rest' ) {\r\n        text = match.input.slice( match.index );\r\n        this.depth++;\r\n      }\r\n\r\n      return this.parse( text, language, tokenizers );\r\n    }\r\n\r\n    this.push( [ category, text ] );\r\n    return text.length;\r\n  }\r\n\r\n  /**\r\n   * Tokenizes the text by the current language.\r\n   *\r\n   * @param text  - A text to tokenize.\r\n   * @param limit - Optional. Limits the ideal number of lines.\r\n   *\r\n   * @return An array with tokens.\r\n   */\r\n  tokenize( text: string, limit?: number ): Token[][] {\r\n    this.lines   = [ [] ];\r\n    this.index   = 0;\r\n    this.limit   = limit || 0;\r\n    this.aborted = false;\r\n\r\n    this.parse( text, this.language, this.language.grammar.main );\r\n\r\n    return this.lines;\r\n  }\r\n}\r\n","/**\n * The line break character.\n *\n * @private\n * @since 0.0.1\n */\nexport const LINE_BREAK = '\\n';\n","import { AnyFunction } from '../types';\n\n\n/**\n * The class for providing the very simple event bus.\n *\n * @private\n * @since 0.0.1\n */\nexport class EventBus {\n  /**\n   * Holds handlers.\n   */\n  protected handlers = {};\n\n  /**\n   * Attaches a handler.\n   *\n   * @param event    - An event name.\n   * @param callback - A callback function to register.\n   * @param priority - Optional. A priority number for the order in which the callbacks are invoked.\n   */\n  on( event: string, callback: AnyFunction, priority = 10 ): void {\n    const handlers = ( this.handlers[ event ] = this.handlers[ event ] || [] );\n    handlers.push( { callback, priority } );\n    handlers.sort( ( handler1, handler2 ) => handler1.priority - handler2.priority );\n  }\n\n  /**\n   * Emits an event.\n   *\n   * @param event - An event name.\n   * @param args  - Optional. Any number of arguments to pass to callbacks.\n   */\n  emit( event, ...args ): void {\n    ( this.handlers[ event ] || [] ).forEach( handler => {\n      handler.callback( ...args );\n    } );\n  }\n\n  /**\n   * Destroys the event bus.\n   */\n  destroy(): void {\n    this.handlers = {};\n  }\n}\n","import { PROJECT_CODE, PROJECT_CODE_SHORT } from './project';\n\n\nexport const ROOT      = PROJECT_CODE;\nexport const CONTAINER = `${ PROJECT_CODE_SHORT }__container`;\nexport const BODY      = `${ PROJECT_CODE_SHORT }__body`;\nexport const CODE      = `${ PROJECT_CODE_SHORT }__code`;\nexport const LINE      = `${ PROJECT_CODE_SHORT }__line`;\nexport const TOKEN     = `${ PROJECT_CODE_SHORT }__token`;\nexport const ACTIVE    = 'is-active';\n","/**\n * The project code name.\n *\n * @since 0.0.1\n */\nexport const PROJECT_CODE = 'ryuseilight';\n\n/**\n * The abbreviated project code.\n *\n * @since 0.0.1\n */\nexport const PROJECT_CODE_SHORT = 'rl';\n","import { LINE_BREAK } from '../../constants/characters';\nimport { Options, LanguageInfo, Token, Component } from '../../types';\nimport { EventBus } from '../../event/EventBus';\nimport { PROJECT_CODE_SHORT } from '../../constants/project';\nimport { BODY, CODE, CONTAINER, LINE, ROOT, TOKEN } from '../../constants/classes';\nimport { forOwn, escapeHtml, tag } from '../../utils';\n\n\n/**\n * Stores all Component functions.\n */\nconst Components: Record<string, Component> = {};\n\n/**\n * The class for highlighting code via provided tokens.\n *\n * @since 0.0.1\n */\nexport class Renderer {\n  /**\n   * Adds components.\n   *\n   * @param components - An object literal with Component functions.\n   */\n  static compose( components: Record<string, Component> ): void {\n    forOwn( components, ( Component, name ) => {\n      Components[ name ] = Component;\n    } );\n  }\n\n  /**\n   * Holds lines with tokens.\n   */\n  readonly lines = [];\n\n  /**\n   * Holds the language info.\n   */\n  readonly info: LanguageInfo;\n\n  /**\n   * Holds the root element if provided.\n   */\n  readonly root: HTMLElement | undefined;\n\n  /**\n   * Holds options.\n   */\n  readonly options: Options;\n\n  /**\n   * Holds the EventBus instance.\n   */\n  readonly event: EventBus = new EventBus();\n\n  /**\n   * The Renderer constructor.\n   *\n   * @param lines   - Lines with tokens to render.\n   * @param info    - The language info object.\n   * @param root    - Optional. A root element to highlight.\n   * @param options - Options.\n   */\n  constructor( lines: Token[][], info: LanguageInfo, root?: HTMLElement, options: Options = {} ) {\n    this.lines   = lines;\n    this.info    = info;\n    this.root    = root;\n    this.options = options;\n\n    this.init();\n  }\n\n  /**\n   * Initializes the instance.\n   */\n  protected init(): void {\n    const { lines } = this;\n\n    if ( lines.length ) {\n      const tokens = lines[ lines.length - 1 ];\n\n      if ( ! tokens.length || ( tokens.length === 1 && ! tokens[ 0 ][ 1 ].trim() ) ) {\n        // Removes the last empty line.\n        lines.pop();\n      }\n    }\n\n    forOwn( Components, Component => {\n      Component( this );\n    } );\n\n    this.event.emit( 'mounted' );\n  }\n\n  /**\n   * Renders lines as HTML.\n   *\n   * @param append - A function to add fragments to the HTML string.\n   *\n   * @return A rendered HTML string.\n   */\n  protected renderLines( append: ( fragment: string ) => void ): void {\n    const event   = this.event;\n    const tagName = this.options.span ? 'span' : 'code';\n\n    for ( let i = 0; i < this.lines.length; i++ ) {\n      const tokens  = this.lines[ i ];\n      const classes = [ LINE ];\n\n      event.emit( 'line:open', append, classes, i );\n      append( tag( classes ) );\n\n      if ( tokens.length ) {\n        for ( let j = 0; j < tokens.length; j++ ) {\n          const token   = tokens[ j ];\n          const classes = [ `${ TOKEN } ${ PROJECT_CODE_SHORT }__${ token[ 0 ] }` ];\n\n          event.emit( 'token', token, classes );\n          append( tag( classes, tagName ) );\n          append( `${ escapeHtml( token[ 1 ] ) }</${ tagName }>` );\n        }\n      } else {\n        append( LINE_BREAK );\n      }\n\n      append( '</div>' );\n      event.emit( 'line:closed', append, i );\n    }\n  }\n\n  /**\n   * Returns all lines and wrapper elements.\n   *\n   * @param pre - Whether to wrap elements by `pre` or not.\n   *\n   * @return An HTML string.\n   */\n  html( pre: boolean ): string {\n    const { event } = this;\n    const closeTag  = '</div>';\n    let html  = '';\n\n    const append = ( fragment: string ) => { html += fragment };\n\n    if ( pre ) {\n      html += tag( [ `${ ROOT } ${ ROOT }--${ this.info.id }` ], 'pre' );\n    }\n\n    const containerClasses = [ CONTAINER ];\n    event.emit( 'open', append, containerClasses );\n    html += tag( containerClasses );\n\n    const bodyClasses = [ `${ BODY }${ this.options.wrap ? ` ${ BODY }--wrap` : '' }` ];\n    event.emit( 'body:open', append, bodyClasses );\n    html += tag( bodyClasses );\n\n    event.emit( 'code:open', append );\n    html += tag( [ CODE ] );\n    this.renderLines( append );\n    html += closeTag; // code\n\n    event.emit( 'body:close', append );\n    html += closeTag; // body\n\n    event.emit( 'close', append );\n    html += closeTag; // container\n\n    event.emit( 'closed', append );\n\n    if ( pre ) {\n      html += `</pre>`;\n    }\n\n    return html;\n  }\n\n  /**\n   * Destroys the instance.\n   */\n  destroy(): void {\n    this.event.emit( 'destroy' );\n    this.event.destroy();\n  }\n}\n","/**\n * Converts essential HTML special characters to HTML entities.\n *\n * @param string - A string to escape.\n *\n * @return An escaped string.\n */\nexport function escapeHtml( string: string ): string {\n  return string.replace( /&/g, '&amp;' ).replace( /</g, '&lt;' );\n}\n","export const REGEXP_FLOAT = /\\d+\\.?\\d*|\\d*\\.?\\d+/;\n\nexport const REGEXP_NUMBER = /[+-]?(\\d+\\.?\\d*|\\d*\\.?\\d+)([eE][+-]?\\d+)?/;\n\nexport const REGEXP_BOOLEAN = /\\b(?:true|false)\\b/;\n\nexport const REGEXP_BRACKET = /[[\\]{}()]/;\n\nexport const REGEXP_SPACE = /[ \\t]+/;\n\nexport const REGEXP_QUOTE = /'(?:\\\\'|.)*?'/;\n\nexport const REGEXP_DOUBLE_QUOTE = /\"(?:\\\\\"|.)*?\"/;\n\nexport const REGEXP_MULTILINE_COMMENT = /\\/\\*[\\s\\S]*?(\\*\\/|$)/;\n\nexport const REGEXP_SLASH_COMMENT = /\\/\\/.*/;\n\nexport const REGEXP_GENERAL_KEYWORDS = /\\b(?:break|catch|class|continue|do|else|extends|finally|for|function|if|implements|in|instanceof|interface|new|null|return|throw|try|while)\\b/;\n","import { Language } from '../../types';\nimport {\n  CATEGORY_BRACKET,\n  CATEGORY_COMMENT,\n  CATEGORY_FUNCTION,\n  CATEGORY_KEYWORD,\n  CATEGORY_NUMBER,\n  CATEGORY_OPERATOR,\n  CATEGORY_PROPERTY,\n  CATEGORY_SELECTOR,\n  CATEGORY_SPACE,\n  CATEGORY_STRING,\n  CATEGORY_DELIMITER,\n  CATEGORY_TAG,\n  CATEGORY_ATRULE,\n} from '../../constants/categories';\nimport { REGEXP_MULTILINE_COMMENT, REGEXP_SPACE } from '../../constants/regexp';\n\n\n/**\n * Returns the CSS language definition.\n *\n * @return A Language object.\n */\nexport function css(): Language {\n  return {\n    id  : 'css',\n    name: 'CSS',\n\n    grammar: {\n      main: [\n        [ '#common' ],\n\n        // An atrule without a block\n        [ '#findSingleAtrule' ],\n\n        // Blocks including atrules\n        [ '#findBlock' ],\n      ],\n\n      findBlock: [\n        [ '#block', /[^ \\t\\r\\n;{}][^;{}]*{.*?}/s, '@rest' ],\n      ],\n\n      findSingleAtrule: [\n        [ '#atrule', /@[^{;]+?;/s ],\n      ],\n\n      // Finds atrules before { and ;\n      findAtrule: [\n        [ '#atrule', /@[^{;]*?(?=[{;])/s ],\n      ],\n\n      // May not start with digits\n      findSelector: [\n        [ '#selector', /[^ \\t\\r\\n{};].*?(?={)/s ],\n      ],\n\n      common: [\n        [ CATEGORY_STRING, /(['\"]).*?[^\\\\]\\1/s ],\n        [ CATEGORY_COMMENT, REGEXP_MULTILINE_COMMENT ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n\n      block: [\n        [ '#inner', /{/, '@rest' ],\n        [ CATEGORY_BRACKET, /}/, '@break' ],\n        [ '#findAtrule' ],\n        [ '#findSelector' ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n\n      inner: [\n        [ CATEGORY_BRACKET, /{/ ],\n        [ '#common' ],\n        [ '#findBlock' ],\n        [ '#props' ],\n        [ '#findAtrule' ],\n        [ '', /}/, '@back' ],\n      ],\n\n      atrule: [\n        [ '#common' ],\n        [ '#url', /\\burl\\(/, '@rest' ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n        [ CATEGORY_ATRULE, /[^\\s();]+/ ],\n        [ CATEGORY_DELIMITER, /[:;,]/ ],\n        [ '#paren', /\\(/, '@rest' ],\n      ],\n\n      paren: [\n        [ CATEGORY_BRACKET, /^\\(/ ],\n        [ '#common' ],\n        [ '#paren', /\\(/, '@rest' ],\n        [ CATEGORY_BRACKET, /\\)/, '@break' ],\n        [ '#props' ],\n      ],\n\n      selector: [\n        [ '#common' ],\n        [ CATEGORY_OPERATOR, /[>+~]/ ],\n        [ CATEGORY_BRACKET, /[[\\]()]/ ],\n        [ CATEGORY_DELIMITER, /=/ ],\n        [ CATEGORY_SELECTOR, /::?\\S+/ ],\n        [ CATEGORY_SELECTOR, /[\\W\\d]\\S+/ ],\n        [ CATEGORY_TAG, /\\b[a-z]+|\\*/i ],\n        [ CATEGORY_SELECTOR, /\\S+/ ],\n      ],\n\n      url: [\n        [ '#common' ],\n        [ CATEGORY_FUNCTION, /^url/ ],\n        [ CATEGORY_BRACKET, /\\(/ ],\n        [ CATEGORY_STRING, /[^)]+/ ],\n        [ CATEGORY_BRACKET, /\\)/, '@break' ],\n      ],\n\n      props: [\n        [ CATEGORY_PROPERTY, /[a-z0-9-_\\xA0-\\uFFFF]+(?=:)/i ],\n        [ '#url', /\\burl\\(/, '@rest' ],\n        [ CATEGORY_FUNCTION, /\\b[\\w-]+(?=\\()\\b/ ],\n        [ CATEGORY_KEYWORD, /!important|\\b(?:initial|inherit|unset)/ ],\n        [ CATEGORY_PROPERTY, /[a-z0-9-]+(?=:)/ ],\n        [ CATEGORY_NUMBER, /#([0-9a-f]{6}|[0-9a-f]{3})/i ],\n        [ CATEGORY_NUMBER, /\\bU\\+[0-9a-f?-]+/i ],\n        [ CATEGORY_NUMBER, /[+-]?(\\d+\\.?\\d*|\\d*\\.?\\d+)/ ],\n        [ CATEGORY_DELIMITER, /[:;,]/ ],\n        [ '#paren', /\\(/, '@rest' ],\n        [ CATEGORY_BRACKET, /[[\\])]/ ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n    },\n  };\n}\n","import {\n  REGEXP_BOOLEAN, REGEXP_BRACKET, REGEXP_DOUBLE_QUOTE, REGEXP_GENERAL_KEYWORDS, REGEXP_MULTILINE_COMMENT,\n  REGEXP_NUMBER, REGEXP_QUOTE, REGEXP_SLASH_COMMENT, REGEXP_SPACE,\n} from '../../constants/regexp';\nimport { Language } from '../../types';\nimport {\n  CATEGORY_DELIMITER, CATEGORY_DECORATOR, CATEGORY_KEYWORD, CATEGORY_REGEXP, CATEGORY_STRING,\n  CATEGORY_OPERATOR, CATEGORY_COMMENT, CATEGORY_CLASS, CATEGORY_FUNCTION, CATEGORY_BOOLEAN,\n  CATEGORY_IDENTIFIER, CATEGORY_NUMBER, CATEGORY_BRACKET, CATEGORY_SPACE,\n} from '../../constants/categories';\n\n\n/**\n * Returns the JavaScript language definition.\n *\n * @return A Language object.\n */\nexport function javascript(): Language {\n  return {\n    id   : 'javascript',\n    name : 'JavaScript',\n    alias: [ 'js' ],\n\n    source: {\n      func: /[_$a-z\\xA0-\\uFFFF][_$a-z0-9\\xA0-\\uFFFF]*/,\n    },\n\n    grammar: {\n      main: [\n        [ CATEGORY_STRING, REGEXP_QUOTE ],\n        [ CATEGORY_STRING, REGEXP_DOUBLE_QUOTE ],\n        [ '#backtick', /`/, '@rest' ],\n        [ CATEGORY_COMMENT, REGEXP_MULTILINE_COMMENT ],\n        [ CATEGORY_COMMENT, REGEXP_SLASH_COMMENT ],\n        [ CATEGORY_REGEXP, /\\/(\\[.*[^\\\\]?]|\\\\\\/|.)+?\\/[gimsuy]*/ ],\n        [ CATEGORY_KEYWORD, REGEXP_GENERAL_KEYWORDS ],\n        [ CATEGORY_KEYWORD, /\\b(?:as|async|await|case|catch|const|debugger|default|delete|enum|export|from|import|let|package|private|protected|public|super|switch|static|this|typeof|undefined|var|void|with|yield)\\b/ ],\n        [ CATEGORY_KEYWORD, /\\b((get|set)(?=\\s+%func))/i ],\n        [ CATEGORY_CLASS, /\\b[A-Z][\\w$]*\\b/ ],\n        [ CATEGORY_FUNCTION, /%func(?=\\s*\\()/i ],\n        [ CATEGORY_BOOLEAN, REGEXP_BOOLEAN ],\n        [ CATEGORY_DECORATOR, /@[^\\s(@]+/ ],\n        [ CATEGORY_IDENTIFIER, /\\b[a-z_$][\\w$]*\\b/ ],\n        [ CATEGORY_NUMBER, REGEXP_NUMBER ],\n        [ CATEGORY_OPERATOR, /=>/ ],\n        [ CATEGORY_OPERATOR, /\\+[+=]?|-[-=]?|\\*\\*?=?|[/%^]=?|&&?=?|\\|\\|?=?|\\?\\??=?|<<?=?|>>>=?|>>?=?|[!=]=?=?|[~:^]/ ],\n        [ CATEGORY_BRACKET, REGEXP_BRACKET ],\n        [ CATEGORY_DELIMITER, /[;.,]+/ ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n\n      backtick: [\n        [ CATEGORY_STRING, /^`/ ],\n        [ CATEGORY_STRING, /(\\$[^{]|\\\\[$`]|[^`$])+/ ],\n        [ '#expression', /\\${/, '@rest' ],\n        [ CATEGORY_STRING, /`/, '@break' ],\n      ],\n\n      expression: [\n        [ CATEGORY_DELIMITER, /^\\${/ ],\n        [ CATEGORY_DELIMITER, /}/, '@break' ],\n        [ '#main' ],\n      ],\n    },\n  };\n}\n","import {\n  CATEGORY_ATTRIBUTE,\n  CATEGORY_BRACKET,\n  CATEGORY_CDATA,\n  CATEGORY_COMMENT,\n  CATEGORY_ENTITY,\n  CATEGORY_PROLOG,\n  CATEGORY_SPACE,\n  CATEGORY_DELIMITER,\n  CATEGORY_TAG,\n  CATEGORY_VALUE,\n} from '../../constants/categories';\nimport { REGEXP_SPACE } from '../../constants/regexp';\nimport { Language, Tokenizer } from '../../types';\nimport { css } from '../css/css';\nimport { javascript } from '../javascript/javascript';\n\n\n/**\n * The HTML language options.\n *\n * @since 0.0.12\n */\nexport interface HtmlOptions {\n  /**\n   * The language for tokenizing script blocks.\n   */\n  script?: () => Language;\n\n  /**\n   * The language for tokenizing style blocks.\n   */\n  style?: () => Language;\n}\n\n/**\n * Returns the HTML language definition.\n *\n * @param options - Optional. Options.\n *\n * @return A Language object.\n */\nexport function html( options: HtmlOptions = {} ): Language {\n  const script = ( options.script || javascript )();\n  const style  = ( options.style || css )();\n  const cdata  = [ CATEGORY_CDATA, /<!\\[CDATA\\[.*]]>/is ] as Tokenizer;\n\n  // Embedded scripts or styles may contain CDATA sections.\n  script.grammar.main.unshift( cdata );\n  style.grammar.main.unshift( cdata );\n\n  return {\n    id   : 'html',\n    alias: [ 'markup' ],\n    name : 'HTML',\n    use  : { script, style },\n\n    grammar: {\n      main: [\n        [ CATEGORY_COMMENT, /<!--.*?-->/s ],\n        [ CATEGORY_PROLOG, /<!DOCTYPE.*?>/is ],\n        cdata,\n        [ '#script', /<script.*?>.*?<\\/script>/s ],\n        [ '#style', /<style.*?>.*?<\\/style>/s ],\n        [ '#tag', /<.*?>/s ],\n        [ CATEGORY_ENTITY, /&[\\da-z]+;|&#\\d+;/i ],\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n      ],\n\n      cdata: [\n        [ CATEGORY_CDATA, /<!\\[CDATA\\[.*]]>/is ],\n      ],\n\n      script: [\n        [ '#tag', /^<script.*?>/s ],\n        [ '#cdata' ],\n        [ '@script', /.+(?=<\\/script>)/s ],\n        [ '#tag', /<\\/script>/ ],\n      ],\n\n      style: [\n        [ '#tag', /^<style.*?>/s ],\n        [ '@style', /.+(?=<\\/style>)/s ],\n        [ '#tag', /<\\/style>/ ],\n      ],\n\n      tag: [\n        [ '#attr', /[ \\t\\r\\n]+.+(?=[ \\t\\r\\n/>])/s ],\n        [ CATEGORY_TAG, /[^\\s/<>\"'=]+/ ],\n        [ CATEGORY_BRACKET, /[<>]/ ],\n        [ CATEGORY_DELIMITER, /[/]/ ],\n      ],\n\n      attr: [\n        [ CATEGORY_SPACE, REGEXP_SPACE ],\n        [ CATEGORY_VALUE, /(['\"])(\\\\\\1|.)*?\\1/ ],\n        [ CATEGORY_DELIMITER, /[/=]/ ],\n        [ CATEGORY_ATTRIBUTE, /[^\\s/>\"'=]+/ ],\n      ],\n    },\n  };\n}\n","import { Language } from '../../types';\nimport { CATEGORY_PROLOG } from '../../constants/categories';\nimport { assign } from '../../utils';\nimport { html } from '../html/html';\n\n\n/**\n * Returns the XML language definition.\n *\n * @return A Language object.\n */\nexport function xml(): Language {\n  const language = assign( html(), {\n    id   : 'xml',\n    name : 'XML',\n    alias: [],\n  } );\n\n  language.grammar.main.unshift( [ CATEGORY_PROLOG, /<\\?.*?\\?>/s ] );\n\n  return language;\n}\n","import { Language, Options, Token } from '../../types';\nimport { Lexer } from '../Lexer/Lexer';\nimport { Renderer } from '../Renderer/Renderer';\nimport { ROOT } from '../../constants/classes';\nimport { ATTRIBUTE_LANGUAGE } from '../../constants/attributes';\nimport { attr, isHTMLElement, text, assert, isString, assign, addClass, toArray } from '../../utils';\nimport { none } from '../../languages';\n\n\n/**\n * Stores all Lexer instances.\n */\nconst lexers: Record<string, Lexer> = {};\n\n/**\n * The class that tokenizes code for syntax highlighting.\n *\n * @since 0.0.1\n */\nexport class RyuseiLight {\n  /**\n   * Registers languages.\n   *\n   * @param languages - A Language object or objects.\n   */\n  static register( languages: Language | Language[] ): void {\n    toArray( languages ).forEach( language => {\n      const { id } = language;\n\n      if ( id && ! lexers[ id ] ) {\n        ( language.alias || [] ).concat( id ).forEach( id => {\n          lexers[ id ] = new Lexer( language );\n        } );\n      }\n    } );\n  }\n\n  /**\n   * Adds components.\n   *\n   * @param components - An object literal with Component functions.\n   */\n  static compose = Renderer.compose;\n\n  /**\n   * Tokenizes the provided string.\n   *\n   * @param code     - A string to tokenize.\n   * @param language - A language ID.\n   * @param limit    - Optional. Limits the (ideal) number of lines.\n   *\n   * @return An array of arrays with tokens as [ string, string ].\n   */\n  static tokenize( code: string, language: string, limit?: number ): Token[][] {\n    return RyuseiLight.getLexer( language ).tokenize( code, limit );\n  }\n\n  /**\n   * Checks if the given language has been already registered or not.\n   *\n   * @param language - A language to check.\n   */\n  static has( language: string ): boolean {\n    return !! lexers[ language ];\n  }\n\n  /**\n   * Returns a registered Lexer instance.\n   * If it's not found, the `none` lexer will be returned.\n   *\n   * @param language - A language name.\n   */\n  protected static getLexer( language: string ) {\n    if ( ! lexers.none ) {\n      RyuseiLight.register( none() );\n    }\n\n    return lexers[ language ] || lexers.none;\n  }\n\n  /**\n   * Holds all renderers.\n   */\n  protected readonly renderers: Renderer[] = [];\n\n  /**\n   * Holds options.\n   */\n  protected readonly options: Options;\n\n  /**\n   * The RyuseiLight constructor.\n   *\n   * @param options  - Optional. Options.\n   */\n  constructor( options?: Options ) {\n    this.options = assign( {}, options );\n  }\n\n  /**\n   * Returns a new Renderer instance.\n   *\n   * @param code    - A code to highlight.\n   * @param elm     - Optional. An element to highlight.\n   * @param options - Optional. Options.\n   */\n  protected getRenderer( code: string, elm?: HTMLElement, options?: Options ) {\n    options = assign( {}, this.options, options );\n\n    const language     = options.language;\n    const { name, id } = RyuseiLight.getLexer( language ).language;\n    return new Renderer( RyuseiLight.tokenize( code, language ), { name, id }, elm, options );\n  }\n\n  /**\n   * Applies the highlighter to elements that matches the selector or the provided element.\n   *\n   * @param target  - A selector or an element.\n   * @param options - Optional. Options.\n   */\n  apply( target: string | Element, options?: Options ): void {\n    const elms = isString( target ) ? document.querySelectorAll( target ) : [ target ];\n\n    for ( let i = 0; i < elms.length; i++ ) {\n      const elm = elms[ i ];\n\n      if ( isHTMLElement( elm ) ) {\n        const elmOptions = assign( {}, options, { language: attr( elm, ATTRIBUTE_LANGUAGE ) || undefined } );\n        const renderer   = this.getRenderer( text( elm ), elm, elmOptions );\n        const isPre      = elm instanceof HTMLPreElement;\n\n        if ( isPre ) {\n          addClass( elm, [ ROOT, `${ ROOT }--${ renderer.info.id }` ] );\n        }\n\n        elm.innerHTML = renderer.html( ! isPre );\n\n        renderer.event.emit( 'applied', elm );\n        this.renderers.push( renderer );\n      }\n    }\n  }\n\n  /**\n   * Returns highlighted HTML by tokenizing the provided code.\n   *\n   * @param code    - Code to highlight.\n   * @param options - Optional. Options.\n   *\n   * @return Highlighted HTML string.\n   */\n  html( code: string, options?: Options ): string {\n    assert( isString( code ), 'Invalid code.' );\n    return this.getRenderer( code, null, options ).html( true );\n  }\n\n  /**\n   * Destroys the instance.\n   */\n  destroy(): void {\n    this.renderers.forEach( renderer => {\n      renderer.destroy();\n    } );\n  }\n}\n","import { Language } from '../../types';\n\n\n/**\n * Returns the None language definition.\n *\n * @return A Language object.\n */\nexport function none(): Language {\n  return {\n    id     : 'none',\n    name   : '',\n    grammar: { main: [] },\n  };\n}\n","import { RyuseiLight } from '../core/RyuseiLight/RyuseiLight';\nimport { none, css, javascript, html, xml } from '../languages';\n\nRyuseiLight.register( [ none(), javascript(), html(), css(), xml() ] );\n\nexport { RyuseiLight as default } from '../core/RyuseiLight/RyuseiLight';\n"],"names":["CATEGORY_KEYWORD","CATEGORY_COMMENT","CATEGORY_SELECTOR","CATEGORY_PROPERTY","CATEGORY_CDATA","CATEGORY_PROLOG","CATEGORY_STRING","CATEGORY_NUMBER","CATEGORY_FUNCTION","CATEGORY_OPERATOR","CATEGORY_BRACKET","CATEGORY_DELIMITER","CATEGORY_SPACE","CATEGORY_TEXT","isObject","subject","isString","isUndefined","toArray","value","Array","isArray","addClass","elm","classes","forEach","name","classList","add","forOwn","object","iteratee","keys","Object","i","length","assign","sources","source","key","attr","attrs","getAttribute","setAttribute","String","tag","join","text","node","textContent","assert","condition","message","Error","startsWith","string","char","charAt","isStickySupported","sticky","Lexer","language","init","grammar","tokenizers","_this","merge","use","this","bind","merged","tokenizer","category","regexp","push","slice","flags","toString","match","replace","replacement","RegExp","parse","index","position","main","aborted","action","lastIndex","exec","handle","depth","token","from","indexOf","sliced","undefined","lines","limit","console","log","lang","input","tokenize","EventBus","on","event","callback","priority","handlers","sort","handler1","handler2","emit","args","handler","destroy","ROOT","BODY","PROJECT_CODE_SHORT","Components","Renderer","info","root","options","compose","components","Component","tokens","trim","pop","_this2","renderLines","append","tagName","span","j","TOKEN","html","pre","closeTag","fragment","id","containerClasses","bodyClasses","wrap","REGEXP_NUMBER","REGEXP_BOOLEAN","REGEXP_BRACKET","REGEXP_SPACE","REGEXP_QUOTE","REGEXP_DOUBLE_QUOTE","REGEXP_MULTILINE_COMMENT","REGEXP_SLASH_COMMENT","REGEXP_GENERAL_KEYWORDS","css","findBlock","findSingleAtrule","findAtrule","findSelector","common","block","inner","atrule","paren","selector","url","props","javascript","alias","func","backtick","expression","script","style","cdata","unshift","lexers","RyuseiLight","register","languages","concat","code","getLexer","has","none","getRenderer","apply","target","elms","document","querySelectorAll","HTMLElement","elmOptions","renderer","isPre","HTMLPreElement","innerHTML","renderers"],"mappings":"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"}